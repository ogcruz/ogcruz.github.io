<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title> 1 Padrões Pontuais | capitulo6.utf8.md</title>
  <meta name="description" content="" />
  <meta name="generator" content="bookdown 0.11 and GitBook 2.6.7" />

  <meta property="og:title" content=" 1 Padrões Pontuais | capitulo6.utf8.md" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content=" 1 Padrões Pontuais | capitulo6.utf8.md" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Estudos Ecológicos</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path=""><a href="#padroes-pontuais"><i class="fa fa-check"></i><b>1</b> Padrões Pontuais</a><ul>
<li class="chapter" data-level="1.1" data-path=""><a href="#o-que-sao-padroes-pontuais"><i class="fa fa-check"></i><b>1.1</b> O que são Padrões Pontuais ?</a></li>
<li class="chapter" data-level="1.2" data-path=""><a href="#tipos-de-distribuicoes"><i class="fa fa-check"></i><b>1.2</b> Tipos de Distribuições</a></li>
<li class="chapter" data-level="1.3" data-path=""><a href="#processos-pontuais"><i class="fa fa-check"></i><b>1.3</b> Processos pontuais</a></li>
<li class="chapter" data-level="1.4" data-path=""><a href="#completa-aletoriedade-espacial-csr---complete-spatial-randomness"><i class="fa fa-check"></i><b>1.4</b> Completa Aletoriedade Espacial (<em>CSR - complete spatial randomness</em>)</a></li>
<li class="chapter" data-level="1.5" data-path=""><a href="#estimativa-de-kernel"><i class="fa fa-check"></i><b>1.5</b> Estimativa de Kernel</a><ul>
<li class="chapter" data-level="1.5.1" data-path=""><a href="#estimativa-de-kernel-com-correcao-por-bordas"><i class="fa fa-check"></i><b>1.5.1</b> Estimativa de Kernel com correção por bordas</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path=""><a href="#kernel-com-variacao-da-populacao"><i class="fa fa-check"></i><b>1.6</b> Kernel com Variação da população</a></li>
<li class="chapter" data-level="1.7" data-path=""><a href="#razao-de-kernel"><i class="fa fa-check"></i><b>1.7</b> Razão de Kernel</a></li>
<li class="chapter" data-level="1.8" data-path=""><a href="#funcao-f-e-g---distancia-do-vizinho-mais-proximo"><i class="fa fa-check"></i><b>1.8</b> Função F e G - Distância do vizinho mais próximo</a></li>
<li class="chapter" data-level="1.9" data-path=""><a href="#funcao-k-de-ripley-ou-apenas-funcao-k."><i class="fa fa-check"></i><b>1.9</b> Função K de Ripley (ou apenas função K).</a></li>
<li class="chapter" data-level="1.10" data-path=""><a href="#funcao-l"><i class="fa fa-check"></i><b>1.10</b> Função <em>L</em></a></li>
<li class="chapter" data-level="1.11" data-path=""><a href="#deteccao-de-cluster"><i class="fa fa-check"></i><b>1.11</b> Detecção de cluster</a><ul>
<li class="chapter" data-level="1.11.1" data-path=""><a href="#testes-genericos-de-cluster"><i class="fa fa-check"></i><b>1.11.1</b> Testes Genéricos de Cluster</a></li>
<li class="chapter" data-level="1.11.2" data-path=""><a href="#fonte-especifica"><i class="fa fa-check"></i><b>1.11.2</b> Fonte Específica</a></li>
</ul></li>
<li class="chapter" data-level="1.12" data-path=""><a href="#exercicios-propostos"><i class="fa fa-check"></i><b>1.12</b> Exercícios Propostos</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:title:end-->
<!--bookdown:title:start-->
<div id="padroes-pontuais" class="section level1">
<h1><span class="header-section-number"> 1</span> Padrões Pontuais</h1>
<div id="o-que-sao-padroes-pontuais" class="section level2">
<h2><span class="header-section-number">1.1</span> O que são Padrões Pontuais ?</h2>
<p>A análise de padrão de pontos, é o tipo mais simples de análise de dados espaciais. Baseia-se na localização dos eventos em um determinada área de estudo a partir das coordenadas. O objetivo é estudar
a disposição espacial dos pontos a partir de suas coordenadas.</p>
<ul>
<li><p>Os processos pontuais são definidos como um conjunto de
pontos cuja localização está em <span class="math inline">\(R^2\)</span>, sendo esse processo gerado por um mecanismo
estocástico.</p></li>
<li><p>Os pontos são os pares de coordenadas <em>(x, y)</em>, que representam os eventos (x: observações, indivíduos, lugares ou qualquer outro objeto discreto definido no espaço).</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="center">Evento</th>
<th align="center">Coord X</th>
<th align="center">Coord Y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">4,30</td>
<td align="center">2,45</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">5,39</td>
<td align="center">3,35</td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center">4,10</td>
<td align="center">3,50</td>
</tr>
</tbody>
</table>
<ul>
<li>Na realidade o que se deseja é detectar padrões de aglomerados espaciais (“clusters”).</li>
</ul>
<p><img src="figuras/pontos1.jpg" style="width:90.0%" /></p>
</div>
<div id="tipos-de-distribuicoes" class="section level2">
<h2><span class="header-section-number">1.2</span> Tipos de Distribuições</h2>
<ul>
<li><p><strong>Aleatória</strong>, qualquer ponto tem a mesma probabilidade de ocorrer em qualquer local
e a posição de qualquer ponto não é afetada pela posição de qualquer outro ponto;</p></li>
<li><p><strong>Uniforme</strong>: cada ponto é tão longe de todos os seus vizinhos quanto possível;</p></li>
<li><p><strong>Cluster</strong>: Muitos pontos estão concentrados juntos, e grandes áreas podem conter pouquíssimos pontos, se houver algum.</p></li>
</ul>
<p><img src="figuras/pp0.jpg" style="width:70.0%" /></p>
<p><a href="https://training.fws.gov/courses/references/tutorials/geospatial/CSP7304/">Fonte: Geospatial Training Workshop</a></p>
<p>Lendo os bancos com as localizações dos casos de homicídios, suicídios e acidentes de carro em Porto Alegre/RS</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(splancs)
<span class="kw">library</span>(spatstat)
<span class="kw">library</span>(gpclib)

<span class="co"># lendo os bancos</span>
local &lt;-<span class="st"> &#39;https://gitlab.procc.fiocruz.br/oswaldo/eco2019/raw/master/dados/&#39;</span>

homic &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="kw">paste0</span>(local,<span class="st">&quot;homic.dat&quot;</span>), <span class="dt">col.names=</span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>))
suic &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="kw">paste0</span>(local,<span class="st">&quot;suic.dat&quot;</span>), <span class="dt">col.names=</span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>))
acid &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="kw">paste0</span>(local,<span class="st">&quot;acid.dat&quot;</span>), <span class="dt">col.names=</span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>))

<span class="co"># Plotando os casos de homicídios em um plano cartesiano</span>
<span class="kw">plot</span>(homic<span class="op">$</span>x,homic<span class="op">$</span>y)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-2-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Porto Alegre é uma cidade disposta ao longo do eixo norte/sul. O grafico perdeu a estrutura espacial, ajustando para o tamanho e forma da janela. Por isso é necessario informar ao programa que este tipo de objeto tem uma escala que deve ser preservada, um objeto do tipo <em>spatial point pattern</em>.</p>
<pre class="sourceCode r"><code class="sourceCode r">homic.spp &lt;-<span class="st"> </span><span class="kw">as.points</span>(homic)
acid.spp &lt;-<span class="st"> </span><span class="kw">as.points</span>(acid)
suic.spp &lt;-<span class="st"> </span><span class="kw">as.points</span>(suic)

<span class="co"># Mapa</span>
<span class="kw">pointmap</span>(homic.spp, <span class="dt">pch=</span><span class="dv">19</span>)

<span class="co"># Adicionando no mapa as outras causas externas</span>

<span class="kw">pointmap</span>(suic.spp, <span class="dt">add=</span>T, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">col=</span><span class="dv">2</span>)
<span class="kw">pointmap</span>(acid.spp, <span class="dt">add=</span>T, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">col=</span><span class="dv">3</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-3-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Importando o poligono do contorno de Porto Alegre</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># contorno de porto alegre</span>
contorno.poa &lt;-<span class="st"> </span><span class="kw">as.points</span>(<span class="kw">read.table</span>(<span class="kw">paste0</span>(local,<span class="st">&quot;contpoa.dat&quot;</span>),<span class="dt">col.names=</span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>)))

<span class="kw">polymap</span>(contorno.poa)
<span class="kw">pointmap</span>(homic.spp, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">add=</span>T,<span class="dt">cex=</span><span class="fl">0.5</span>)
<span class="kw">pointmap</span>(suic.spp, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">2</span>,<span class="dt">cex=</span><span class="fl">0.5</span>)
<span class="kw">pointmap</span>(acid.spp, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">3</span>,<span class="dt">cex=</span><span class="fl">0.5</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-4-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Os pontos fora do contorno sao das ilhas, nao devem ser incorporados a analise.</p>
<pre class="sourceCode r"><code class="sourceCode r">homic2.spp &lt;-<span class="st"> </span><span class="kw">delpoints</span>(homic.spp)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-5-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Este comando é igual ao identify, clique em cada ponto que deseja deletar. Para terminar clique 2 vezes com o botao da direita</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">polymap</span>(contorno.poa)
<span class="kw">pointmap</span>(homic2.spp, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">add=</span>T,<span class="dt">cex=</span><span class="fl">0.5</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-7-1.png" width="100%" style="display: block; margin: auto;" /></p>
</div>
<div id="processos-pontuais" class="section level2">
<h2><span class="header-section-number">1.3</span> Processos pontuais</h2>
<p>Os processos pontuais podem ser descritos como:</p>
<ol style="list-style-type: lower-roman">
<li><strong>Processo de primeira ordem</strong>, considerados globais ou de larga escala, que correspondem a variações no valor médio do processo no espaço.</li>
</ol>
<ul>
<li>Tal processo pode ser representado por mensurações da intensidade baseado na densidade dos pontos (média dos eventos) na área de estudo (ex: Estimativa de Kernel).</li>
</ul>
<ol start="2" style="list-style-type: lower-roman">
<li><strong>Processo de segunda ordem</strong>, denominados locais ou de pequena escala, é o processo representado pela interação entre dois pontos arbitrários.</li>
</ol>
<ul>
<li>O objetivo desse processo é a mensuração da dependência espacial baseado na distância entre os pontos (ex: Vizinhos mais próximos, Função K).</li>
</ul>
</div>
<div id="completa-aletoriedade-espacial-csr---complete-spatial-randomness" class="section level2">
<h2><span class="header-section-number">1.4</span> Completa Aletoriedade Espacial (<em>CSR - complete spatial randomness</em>)</h2>
<p><span class="math inline">\(H_0\)</span>: Os pontos estão distribuidos aleatoriamente no espaço</p>
<p><span class="math inline">\(H_1\)</span>: Os pontos podem formar clusters ou estão dispersos no espaço</p>
<ul>
<li><p><em>CSR</em> assume que os pontos seguem um processo homogênio de Poisson na área de estudo.</p>
<!-- - A densidade dos pontos é constante homogênea ao longo da área de estudo; -->
<!-- - Para uma amostra aleatória de subregiões, a distribuição da frequência do número de pontos em cada região segue uma distribuição de poisson; --></li>
</ul>
<!--     - O número de pontos em uma dada subregião e o mesmo para todas as subregiões na área de estudo; -->
<p><!-- - O número de pontos na subregião, independe do número de pontos em qualquer outra subregião. --></p>
<p>Simulando alguns padrões dos dados de ponto, temos o seguinte:</p>
<ul>
<li>Simulando os processo espaciais</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">9999</span>)
<span class="co"># Criando uma caixa envoltoria</span>
caixa &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>),<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>),<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>),<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>))

<span class="co"># Simulando um processo espacial aletaorio</span>
<span class="co">#csr significa &quot;complete spatial randomness&quot;</span>
alea.spp &lt;-<span class="st"> </span><span class="kw">csr</span>(caixa,<span class="dv">100</span>)

<span class="co"># Processo de poisson clusterizado</span>
clu.spp &lt;-<span class="st"> </span><span class="kw">pcp.sim</span>(<span class="dt">rho=</span><span class="dv">20</span>,<span class="dt">m=</span><span class="dv">10</span>,<span class="dt">s2=</span><span class="fl">0.005</span>, <span class="dt">region.poly=</span>caixa)
<span class="co"># rho= intensidade do processo de poisson &quot;pai&quot;(gerador)</span>
<span class="co"># m=media </span>
<span class="co"># s2=variancia </span>

<span class="co"># Distribuicao regular</span>
uni.spp &lt;-<span class="st"> </span><span class="kw">jitter</span>(<span class="kw">gridpts</span>(caixa,<span class="dv">100</span>),<span class="dv">2</span>)
<span class="co"># o comando jitter cria uma flutuacao aleatoria sobre os valores</span>
<span class="co"># o comando gridpts gera uma grade regular</span>
<span class="co"># 2 e&#39; o fator de confusao adicionado ao grid regular</span></code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">plot</span>(alea.spp, <span class="dt">main=</span><span class="st">&quot;Aleatório&quot;)</span>
<span class="st">plot(uni.spp, main=&quot;</span>Regular<span class="st">&quot;)</span>
<span class="st">plot(clu.spp, main=&quot;</span>Agregado<span class="st">&quot;)</span></code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-9-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Verificando a distribuição dos pontos por quadrantes</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Convertendo para a class ppp</span>
<span class="kw">library</span>(spatstat)
alea.ppp &lt;-<span class="st"> </span><span class="kw">as.ppp</span>(alea.spp, <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>))
uni.ppp &lt;-<span class="st"> </span><span class="kw">as.ppp</span>(uni.spp, <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>))
clu.ppp &lt;-<span class="st"> </span><span class="kw">as.ppp</span>(clu.spp, <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>))

<span class="co"># Construindo os quadrantes com as respectivas contagens</span>
aleatorioQ &lt;-<span class="st"> </span><span class="kw">quadratcount</span>(alea.ppp, <span class="dt">nx =</span> <span class="dv">4</span>, <span class="dt">ny =</span> <span class="dv">4</span>)
regularQ &lt;-<span class="st"> </span><span class="kw">quadratcount</span>(uni.ppp, <span class="dt">nx =</span> <span class="dv">4</span>, <span class="dt">ny =</span> <span class="dv">4</span>)
agregadoQ &lt;-<span class="st"> </span><span class="kw">quadratcount</span>(clu.ppp, <span class="dt">nx =</span> <span class="dv">4</span>, <span class="dt">ny =</span> <span class="dv">4</span>)


<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">plot</span>(aleatorioQ, <span class="dt">main=</span><span class="st">&quot;Aleatório&quot;)</span>
<span class="st">plot(alea.ppp, add = TRUE)</span>

<span class="st">plot(regularQ, main=&quot;</span>Regular<span class="st">&quot;)</span>
<span class="st">plot(uni.ppp, add = TRUE)</span>

<span class="st">plot(agregadoQ, main=&quot;</span>Agregado<span class="st">&quot;)</span>
<span class="st">plot(clu.ppp, add = TRUE)</span></code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-10-1.png" width="100%" style="display: block; margin: auto;" /></p>
<ul>
<li>Testando a Completa Aletoriedade Espacial (<em>CSR - complete spatial randomness</em>)</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">quadrat.test</span>(aleatorioQ)</code></pre>
<pre><code>
    Chi-squared test of CSR using quadrat counts
    Pearson X2 statistic

data:  
X2 = 11.68, df = 15, p-value = 0.5939
alternative hypothesis: two.sided

Quadrats: 4 by 4 grid of tiles</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">quadrat.test</span>(agregadoQ)</code></pre>
<pre><code>
    Chi-squared test of CSR using quadrat counts
    Pearson X2 statistic

data:  
X2 = 93.052, df = 15, p-value = 5.33e-13
alternative hypothesis: two.sided

Quadrats: 4 by 4 grid of tiles</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">quadrat.test</span>(regularQ)</code></pre>
<pre><code>
    Chi-squared test of CSR using quadrat counts
    Pearson X2 statistic

data:  
X2 = 2.4, df = 15, p-value = 0.0001956
alternative hypothesis: two.sided

Quadrats: 4 by 4 grid of tiles</code></pre>
</div>
<div id="estimativa-de-kernel" class="section level2">
<h2><span class="header-section-number">1.5</span> Estimativa de Kernel</h2>
<p>Uma análise exploratória de um processo pontual começa pela estimação da intensidade de ocorrências do processo em toda a região em estudo. Com isso, gera-se uma superfı́cie cujo valor é proporcional à intensidade de eventos por unidade de área;</p>
<p>O estimador Kernel é um interpolador, que possibilita a estimação da intensidade do evento em toda a área, mesmo nas regiões onde o processo não tenha gerado nenhuma ocorrência real.</p>
<p>Essa técnica de alisamento, utiliza janela móvel que para cada área estima um peso variável conforme a distância.</p>
<p>O objetivo é de estimar a intensidade do processo pontual <span class="math inline">\(=\)</span> número de eventos por unidade de área</p>
<p><img src="figuras/pp3.jpg" style="width:100.0%" /></p>
<p><span class="math display">\[\hat{\lambda}(s) = \sum\limits_{i=1}^{n} \dfrac{1}{\tau^2} K \left( \frac{(s - s_i)}{\tau} \right) \nonumber\]</span></p>
<p>Sendo:</p>
<ul>
<li><p><span class="math inline">\(\hat{\lambda}(s)\)</span> - valor estimado por área;</p></li>
<li><p>A função <span class="math inline">\(K(\bullet)\Rightarrow\)</span> FDP, escolhida de forma adequada para construir uma superfície contínua sobre os dados;</p></li>
<li><p>O parâmetro <span class="math inline">\(\tau\)</span> denominado “largura de banda ou faixa”&quot; (<strong>bandwidth</strong>), controla o amaciamento da superfície gerada;</p></li>
<li><p><span class="math inline">\(s\)</span> centro da área, representada por uma localização qualquer na área de estudo;</p></li>
<li><p><span class="math inline">\(S_i\)</span> são as localizações dos eventos observados;</p></li>
<li><p><span class="math inline">\(n\)</span> representa o número de pontos (eventos).</p></li>
</ul>
<p><img src="figuras/pp5.jpg" style="width:100.0%" /></p>
<!-- - Foi desenvolvida originalmente para obter uma estimação alisada -->
<!-- da densidade de probabilidade uni ou multivariada, ou um -->
<!-- histograma alisado. -->
<!-- - Estimar a intensidade de pontos dispostos no espaço é semelhante a estimar uma densidade de probabilidade bivariada. -->
<div id="estimativa-de-kernel-com-correcao-por-bordas" class="section level3">
<h3><span class="header-section-number">1.5.1</span> Estimativa de Kernel com correção por bordas</h3>
<p>Primeiramente calcula-se o volume sob o Kernel que está de fato dentro da região de estudo.</p>
<p><span class="math display">\[\delta_{\tau}(s) = \int_{R}\dfrac{1}{\tau^2}k \left( \dfrac{(s-u)}{\tau}\right) du\]</span></p>
<p>Aplicando a correção das bordas obtém-se um estimador corrigido:</p>
<p><span class="math display">\[\hat{\lambda}(s) = \dfrac{1}{\delta_{\tau}(s)} \sum\limits_{i=1}^{n} \dfrac{1}{\tau^2} K \left( \frac{(s - s_i)}{\tau} \right) \nonumber\]</span></p>
<p><strong>Exemplo:</strong></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Analisando o efeito de primeira ordem: variacao da intensidade</span>
<span class="co"># kernel quartico</span>

alea.ker &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(alea.spp,caixa,<span class="dt">h0=</span>.<span class="dv">1</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)
clu.ker &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(clu.spp,caixa,<span class="dt">h0=</span>.<span class="dv">1</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)
uni.ker &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(uni.spp,caixa,<span class="dt">h0=</span>.<span class="dv">1</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">image</span>(alea.ker, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>),  <span class="dt">main=</span><span class="st">&quot;Aleatorio&quot;</span>)
<span class="kw">pointmap</span>(alea.spp, <span class="dt">add=</span>T,<span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)

<span class="kw">image</span>(uni.ker, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Regular&quot;</span>)
<span class="kw">pointmap</span>(uni.spp, <span class="dt">add=</span>T,<span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)

<span class="kw">image</span>(clu.ker, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Cluster&quot;</span>)
<span class="kw">pointmap</span>(clu.spp, <span class="dt">add=</span>T,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-14-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Alterando a largura de banda de forma exploratoria</p>
<pre class="sourceCode r"><code class="sourceCode r">clu.ker &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(clu.spp,caixa,<span class="dt">h0=</span>.<span class="dv">05</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)
clu.ker1 &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(clu.spp,caixa,<span class="dt">h0=</span>.<span class="dv">2</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)
clu.ker2 &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(clu.spp,caixa,<span class="dt">h0=</span>.<span class="dv">5</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)


<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">image</span>(clu.ker, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Cluster - Tau = 0.05&quot;</span>)
<span class="kw">pointmap</span>(clu.spp, <span class="dt">add=</span>T)
<span class="kw">image</span>(clu.ker1, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Cluster - Tau = 0.2&quot;</span>)
<span class="kw">pointmap</span>(clu.spp, <span class="dt">add=</span>T)
<span class="kw">image</span>(clu.ker2, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Cluster - Tau = 0.5&quot;</span>)
<span class="kw">pointmap</span>(clu.spp, <span class="dt">add=</span>T)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-15-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Passando as linhas de contorno</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">image</span>(alea.ker, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>),  <span class="dt">main=</span><span class="st">&quot;Aleatorio&quot;</span>)
<span class="kw">contour</span>(alea.ker,<span class="dt">add=</span>T)

<span class="kw">image</span>(uni.ker, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Regular&quot;</span>)
<span class="kw">contour</span>(uni.ker,<span class="dt">add=</span>T)

<span class="kw">image</span>(clu.ker, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Cluster&quot;</span>)
<span class="kw">contour</span>(clu.ker,<span class="dt">add=</span>T)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-16-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Kernel 3D</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">persp</span>(clu.ker)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-17-1.png" width="100%" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">persp</span>(clu.ker,<span class="dt">theta =</span> <span class="dv">20</span>,<span class="dt">phi =</span> <span class="dv">30</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-17-2.png" width="100%" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">persp</span>(clu.ker,<span class="dt">phi =</span> <span class="dv">45</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-17-3.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Estimando a largura de banda otima</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Mean Square Error for a Kernel Smoothing - Mse</span>
Mse2d &lt;-<span class="st"> </span><span class="kw">mse2d</span>(clu.spp, caixa, <span class="dt">nsmse=</span><span class="dv">20</span>,<span class="dt">range=</span><span class="fl">0.2</span>)
<span class="kw">plot</span>(Mse2d<span class="op">$</span>h,Mse2d<span class="op">$</span>mse, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;h&quot;</span>,  <span class="dt">ylab=</span><span class="st">&quot;Mse&quot;</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-18-1.png" width="100%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="kernel-com-variacao-da-populacao" class="section level2">
<h2><span class="header-section-number">1.6</span> Kernel com Variação da população</h2>
<ul>
<li><p>O alisamento Kernel permite estimar “eventos por unidade de área”, sem considerar a população.</p></li>
<li><p>Pode-se estimar “população por unidade de área”, e fazer a razão dos dois obtendo uma estimativa alisada de “eventos por população”</p></li>
</ul>
<p><span class="math display">\[\hat{\lambda}(s) = \sum\limits_{i=1}^{n} \dfrac{1}{\tau^2} K \left( \frac{(s - s&#39;_j)}{\tau} \right) y_i \nonumber\]</span></p>
<p>Sendo:</p>
<p><span class="math inline">\(\lambda&#39;\)</span> - Estimativa populacional para unidade de área</p>
<p><span class="math inline">\(\tau\)</span> - Largura de banda</p>
<p><span class="math inline">\(y_i\)</span> - População em cada ponto</p>
<p>Usa-se atribuir ao centróide do setor censitário ou ao centro populacional o número de habitantes de toda a área</p>
</div>
<div id="razao-de-kernel" class="section level2">
<h2><span class="header-section-number">1.7</span> Razão de Kernel</h2>
<p>A criação da taxa é a divisão dos alisamentos: eventos por unidade de área
população por unidade de área</p>
<p><span class="math display">\[\hat{\lambda}(s) = \dfrac{\sum\limits_{i=1}^{n} \dfrac{1}{\tau^2} K \left( \frac{(s - s_i)}{\tau} \right)}{\sum\limits_{i=1}^{n} \dfrac{1}{\tau^2} K \left( \frac{(s - s&#39;_j)}{\tau} \right) y_i} \nonumber\]</span></p>
<ul>
<li><p>Pode-se usar diferentes larguras de banda (em geral maior no denominador para estabilizar mais)</p></li>
<li><p>Pode-se usar outro evento como “estimador da população a risco”</p></li>
</ul>
<p><strong>Exemplo:</strong>Comparando 2 eventos (casos clusterizados - <strong>casos</strong> vs casos aleatórios - <strong>controle</strong></p>
<pre class="sourceCode r"><code class="sourceCode r">clu.ker2 &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(clu.spp, caixa,<span class="dt">h0=</span><span class="fl">0.2</span>,<span class="dt">nx=</span><span class="dv">100</span>, <span class="dt">ny=</span><span class="dv">100</span>)
clualea.ratio &lt;-<span class="st"> </span><span class="kw">kernrat</span>(clu.spp, alea.spp,caixa, h1 &lt;-<span class="st"> </span><span class="fl">0.2</span>, h2 &lt;-<span class="st"> </span><span class="fl">0.2</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))
<span class="kw">image</span>(clu.ker2, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Cluster&quot;</span>)
<span class="kw">pointmap</span>(clu.spp, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">2</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.7</span>)

<span class="kw">image</span>(clualea.ratio, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>), <span class="dt">main=</span><span class="st">&quot;Razao Cluster/Aleatorio&quot;</span>)
<span class="kw">pointmap</span>(clu.spp, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">2</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.7</span>)
<span class="kw">pointmap</span>(alea.spp, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">4</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.7</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-19-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p><strong>Exemplo</strong>: Verificando o padrão espacial de segunda ordem dos casos de homicíodos em POA/RS</p>
<pre class="sourceCode r"><code class="sourceCode r">homicKer500 &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(homic2.spp,contorno.poa,<span class="dt">h0=</span><span class="dv">100</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)
homicKer1500 &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(homic2.spp,contorno.poa,<span class="dt">h0=</span><span class="dv">500</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)
homicKer2500 &lt;-<span class="st"> </span><span class="kw">kernel2d</span>(homic2.spp,contorno.poa,<span class="dt">h0=</span><span class="dv">1500</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">polymap</span>(contorno.poa,<span class="dt">axes=</span><span class="ot">FALSE</span>)
<span class="kw">image</span>(homicKer500 , <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>),<span class="dt">add=</span><span class="ot">TRUE</span>)
<span class="kw">pointmap</span>(homic2.spp, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">4</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.5</span>)
<span class="kw">title</span>(<span class="st">&quot;Homicidios - 500m&quot;</span>)

<span class="kw">polymap</span>(contorno.poa,<span class="dt">axes=</span><span class="ot">FALSE</span>)
<span class="kw">image</span>(homicKer1500, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>),<span class="dt">add=</span><span class="ot">TRUE</span>)
<span class="kw">pointmap</span>(homic2.spp, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">4</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.5</span>)
<span class="kw">title</span>(<span class="st">&quot;Homicidios - 1500m&quot;</span>)

<span class="kw">polymap</span>(contorno.poa,<span class="dt">axes=</span><span class="ot">FALSE</span>)
<span class="kw">image</span>(homicKer2500, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>),<span class="dt">add=</span><span class="ot">TRUE</span>)
<span class="kw">pointmap</span>(homic2.spp, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">4</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.5</span>)
<span class="kw">title</span>(<span class="st">&quot;Homicidios - 2500m&quot;</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-20-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exemplo:</strong>Fazendo a razão de kernel entre as causas de homicídio e suicídios de Porto alegre/RS</p>
<pre class="sourceCode r"><code class="sourceCode r">kernel.ratio &lt;-<span class="st"> </span><span class="kw">kernrat</span>(homic2.spp, suic.spp,contorno.poa,
                        <span class="dt">h1=</span><span class="dv">500</span>, <span class="dt">h2=</span><span class="dv">750</span>,<span class="dt">nx=</span><span class="dv">100</span>,<span class="dt">ny=</span><span class="dv">100</span>)

<span class="kw">polymap</span>(contorno.poa,<span class="dt">axes=</span><span class="ot">FALSE</span>)
<span class="kw">image</span>(kernel.ratio, <span class="dt">col=</span><span class="kw">gray</span>(<span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">/</span><span class="dv">32</span>),<span class="dt">add=</span>T)
<span class="kw">pointmap</span>(homic2.spp, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">2</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.4</span>)
<span class="kw">pointmap</span>(suic.spp, <span class="dt">add=</span>T, <span class="dt">col=</span><span class="dv">4</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.4</span>)
<span class="kw">title</span>(<span class="st">&quot;Razao Homicidio/Suicidio&quot;</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p><strong>Exemplo:</strong> Uma outra forma de fazer o kernel para os dados de homcídio de POA/RS</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">## construindo a grade de interpolação</span>
<span class="co">#range(contorno.poa[,1])</span>
<span class="co">#range(contorno.poa[,2])</span>
<span class="kw">bbox</span>(contorno.poa)</code></pre>
<pre><code>        min      max
x  17393.48  19826.3
y 164980.60 168497.5</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">grade &lt;-<span class="st">  </span><span class="kw">GridTopology</span>(<span class="dt">cellcentre.offset=</span><span class="kw">c</span>(<span class="dv">17393</span>,<span class="dv">164998</span>),
                       <span class="dt">cellsize=</span><span class="kw">c</span>(<span class="dv">10</span>,<span class="dv">10</span>),<span class="dt">cells.dim=</span><span class="kw">c</span>(<span class="dv">239</span>,<span class="dv">345</span>))

<span class="co">## selecao de largura de banda no olho</span>
<span class="kw">polymap</span>(contorno.poa)
<span class="kw">pointmap</span>(homic2.spp,<span class="dt">add=</span>T,<span class="dt">col=</span><span class="dv">4</span>,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.7</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-22-1.png" width="100%" style="display: block; margin: auto;" /></p>
<pre><code>procure olhando nas coordenadas qual seria uma distancia &quot;razoavel&quot;
observe que de um extremo a outro do mapa temos 2390 (na horizontal). 
Entao uma distancia razoável seria...</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">## seleção de largura de banda por mínimos quadrados</span>
xx &lt;-<span class="st"> </span><span class="kw">mse2d</span>(homic2.spp, contorno.poa,<span class="dt">nsmse=</span><span class="dv">50</span>,<span class="dt">range=</span><span class="dv">100</span>)
<span class="kw">plot</span>(xx<span class="op">$</span>h, xx<span class="op">$</span>mse,  <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;h&quot;</span>,  <span class="dt">ylab=</span><span class="st">&quot;Mse&quot;</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-23-1.png" width="100%" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r">homic.ker5 &lt;-<span class="st"> </span><span class="kw">spkernel2d</span>(homic2.spp, contorno.poa, <span class="dt">h0=</span><span class="dv">100</span>, <span class="dt">grd=</span>grade)
homic.ker10 &lt;-<span class="st"> </span><span class="kw">spkernel2d</span>(homic2.spp, contorno.poa, <span class="dt">h0=</span><span class="dv">200</span>, <span class="dt">grd=</span>grade)
homic.ker15 &lt;-<span class="st"> </span><span class="kw">spkernel2d</span>(homic2.spp, contorno.poa, <span class="dt">h0=</span><span class="dv">500</span>, <span class="dt">grd=</span>grade)
homic.ker20 &lt;-<span class="st"> </span><span class="kw">spkernel2d</span>(homic2.spp, contorno.poa, <span class="dt">h0=</span><span class="dv">750</span>, <span class="dt">grd=</span>grade)


df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">ker100=</span>homic.ker5, <span class="dt">ker200=</span>homic.ker10, 
                 <span class="dt">ker500=</span>homic.ker15,<span class="dt">ker750=</span>homic.ker20)

kernels &lt;-<span class="st"> </span><span class="kw">SpatialGridDataFrame</span>(grade,<span class="dt">data=</span>df)

<span class="kw">spplot</span>(kernels,<span class="dt">col.regions=</span><span class="kw">terrain.colors</span>(<span class="dv">16</span>),<span class="dt">cuts=</span><span class="dv">15</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-24-1.png" width="100%" style="display: block; margin: auto;" /></p>
</div>
<div id="funcao-f-e-g---distancia-do-vizinho-mais-proximo" class="section level2">
<h2><span class="header-section-number">1.8</span> Função F e G - Distância do vizinho mais próximo</h2>
<ul>
<li><p>Kernel e quadrat permitem explorar a variação da média do processo na região de
estudo (propriedade de primeira ordem)</p></li>
<li><p>Para investigar propriedade de segunda ordem é necessário observar as distâncias
entre os eventos</p></li>
<li><p>O método do vizinho mais próximo estima a função de distribuição
cumulativa baseado nas distâncias entre eventos ou pntos em uma região de análise.</p></li>
<li><p>Dois tipos de distâncias: <strong>evento-evento (W)</strong> e <strong>ponto aleatório-evento (X)</strong></p></li>
</ul>
<p><span class="math display">\[\hat{F}(x) = \dfrac{\#(x_i \leq x)}{m}\]</span></p>
<p><span class="math display">\[\hat{G}(w) = \dfrac{\#(w_i \leq w)}{n}\]</span></p>
<ul>
<li>Sabendo que:</li>
</ul>
<p><em>W</em> - evento-evento</p>
<p><em>X</em> - ponto-evento</p>
<p><em>#</em> - contagem de pontos onde a condição acontece</p>
<p><em>n</em> - total de eventos</p>
<p><em>m</em> - total de pontos aleatórios</p>
<ul>
<li><p>Em ambas funções, podemos dizer que podem ser representadas pelo número de (<span class="math inline">\(x_i\)</span>) ou ponto (<span class="math inline">\(w_i\)</span>) cuja distância é menor ou igual ao evento (<span class="math inline">\(x\)</span>) ou ponto (<span class="math inline">\(w\)</span>), dividido pelo total de pontos (<span class="math inline">\(m\)</span>) ou total de eventos (<span class="math inline">\(n\)</span>) na região.</p></li>
<li><p>O resultado desta função empírica é o histograma das distâncias para o vizinho
mais próximo - cada classe do histograma é uma contagem de eventos que ocorrem até
aquela distância</p></li>
</ul>
<p>A plotagem dos resultados desta função de distribuição cumulativa empírica pode ser usada como um método exploratório para se verificar se existe evidência de interação entre os eventos. Se esta plotagem apresentar um crescimento rápido para pequenos valores de distância, esta situação aponta para interação entre os eventos caracterizando agrupamentos nestas escalas. Se esta plotagem apresentar valores pequenos no seu início, e só crescer rapidamente para
valores maiores de distância, esta situação aponta para uma distribuição mais regular.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">plot</span>(<span class="kw">envelope</span>(<span class="dt">Y =</span> alea.ppp, <span class="dt">fun =</span> Gest, <span class="dt">nsim =</span> <span class="dv">99</span>), <span class="dt">main=</span><span class="st">&quot;Aleatório&quot;)</span>
<span class="st">plot(envelope(Y = uni.ppp, fun = Gest, nsim = 99), main=&quot;</span>Regular<span class="st">&quot;)</span>
<span class="st">plot(envelope(Y = clu.ppp, fun = Gest, nsim = 99), main=&quot;</span>Agregado<span class="st">&quot;)</span></code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-25-1.png" width="672" style="display: block; margin: auto;" />
Embora o método do vizinho mais próximo forneça uma indicação inicial da distribuição espacial, ele considera apenas escalas pequenas. Para se ter informação mais efetiva para o padrão espacial em escalas maiores, o melhor método a ser utilizado é o da função <span class="math inline">\(K\)</span>.</p>
</div>
<div id="funcao-k-de-ripley-ou-apenas-funcao-k." class="section level2">
<h2><span class="header-section-number">1.9</span> Função K de Ripley (ou apenas função K).</h2>
<ul>
<li>A função <span class="math inline">\(K\)</span> permite analisar as propriedades de segunda ordem de um processo isotrópico</li>
</ul>
<p><span class="math display">\[\lambda K(h) = E(\#eventos)\]</span></p>
<p>Sendo:</p>
<ul>
<li><p><span class="math inline">\(#eventos\)</span> - é o número de eventos esperados até distância <span class="math inline">\(h\)</span></p></li>
<li><p><span class="math inline">\(\lambda\)</span> é a intensidade ou número médio de eventos por unidade de área</p></li>
</ul>
<p>eventos contidos a uma distância h de um evento arbitrário<span class="math inline">\()\)</span></p>
<ul>
<li>A função <span class="math inline">\(K(h)\)</span> é, para cada distância <span class="math inline">\(h\)</span>, o somatório do total de pares cuja distância é menor de que <span class="math inline">\(h\)</span>, vezes o inverso do total de pares ordenados existente na região <span class="math inline">\(R\)</span>.</li>
</ul>
<p><span class="math display">\[K(h) = \dfrac{1}{\lambda^{2} R}\sum \sum\limits_{i \neq j} I_{h} (d_{ij})\]</span></p>
<p>Supondo:</p>
<p><span class="math display">\[I_{h}(d_{ij}) = \begin{cases} 1  \ \ se\ \  d_{ij} \leq h \\ 0 \ \ se\ \  d_{ij} &gt; h \end{cases}\]</span></p>
<p><span class="math inline">\(I_{h}(d_{ij})\)</span> é uma função indicador</p>
<ul>
<li><p>Esta função também necessita de correção do efeito de borda</p></li>
<li><p>A função <em>K</em> de Ripley conta quantos pontos há em círculos em torno de uma planta focal;</p></li>
<li><p>Os círculos começam com um raio pequeno e vão até um raio que inclui toda a área de estudo;</p></li>
<li><p>Faz-se uma média do número de pontos nas classes de distâncias em torno de todas as plantas focais da população.</p></li>
</ul>
<p><img src="figuras/ripley.png" style="width:100.0%" /></p>
<ul>
<li>A distribuição é cumulativa e representa o no esperado de vizinhos em um círculo de raio <em>r</em> centrado em uma planta arbitrária dividido pela intensidade <em>λ</em> do padrão dos pontos na área de estudo;</li>
</ul>
<p>Possíveis resultados:</p>
<ul>
<li><p><strong>quando o processo é completamente aleatório</strong>, a curva se desvia relativamente pouco de <span class="math inline">\(\pi r²\)</span>. A curva <span class="math inline">\(K\)</span> permanece perto de o valor de referência <span class="math inline">\(\pi r²\)</span>;</p></li>
<li><p><strong>no caso de um processo regular</strong>, obtemos: <span class="math inline">\(\hat{K}(r) &lt; K_{pois}(r)\)</span> porque se os pontos forem repulsivo, eles têm menos vizinhos em média em um raio <span class="math inline">\(r\)</span> do que teriam baseado no pressuposto de uma distribuição aleatória de pontos. Graficamente, a curva K reflete isso repulsão: vemos que no gráfico à abaixo, no processo regular, a curva K está localizada abaixo da referência valor (<span class="math inline">\(\pi r²\)</span>);</p></li>
<li><p><strong>no caso de um processo agregado</strong>, há em média mais pontos em um raio <span class="math inline">\(r\)</span> ao redor os pontos do que o número esperado sob uma distribuição aleatória: consequentemente, os pontos atraem um ao outro e <span class="math inline">\(\hat{K}(r) &gt; K_{pois}(r)\)</span>. Graficamente, a curva <span class="math inline">\(K\)</span> está neste momento localizada acima da
valor de referência para todas as áreas de estudo.</p></li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">plot</span>(<span class="kw">envelope</span>(<span class="dt">Y =</span> alea.ppp, <span class="dt">fun =</span> Kest, <span class="dt">nsim =</span> <span class="dv">99</span>), <span class="dt">main=</span><span class="st">&quot;Aleatório&quot;)</span>
<span class="st">plot(envelope(Y = uni.ppp, fun = Kest, nsim = 99), main=&quot;</span>Regular<span class="st">&quot;)</span>
<span class="st">plot(envelope(Y = clu.ppp, fun = Kest, nsim = 99), main=&quot;</span>Agregado<span class="st">&quot;)</span></code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-26-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="funcao-l" class="section level2">
<h2><span class="header-section-number">1.10</span> Função <em>L</em></h2>
<ul>
<li>A função <span class="math inline">\(K(h)\)</span> tem uma distribuição teórica sob condições de aleatoriedade, quando a probabilidade de ocorrência de um evento em qualquer ponto de <em>R</em> é independente da ocorrência de outros eventos e igual em toda a superfície.</li>
</ul>
<p>Neste caso, o número de eventos a uma distância <span class="math inline">\(h\)</span> será <span class="math inline">\(\pi \lambda h^2\)</span>:</p>
<p><span class="math display">\[ K(h) = \pi h^2\]</span></p>
<p>No caso de distribuição regular, <span class="math inline">\(K(h)\)</span> será menor que <span class="math inline">\(\pi h^2\)</span>.</p>
<p>Distribuição em cluster, K(h) será maior que <span class="math inline">\(\pi h^2\)</span>.</p>
<p>A função <span class="math inline">\(L(h)\)</span> permite comparar a função <span class="math inline">\(K(h)\)</span> e <span class="math inline">\(\pi h^2\)</span></p>
<p><span class="math display">\[L(h) = \sqrt {\dfrac{K(h)}{\pi}}\]</span></p>
<pre><code>- Picos positivos indicam atração espacial - cluster

- Vales negativos - repulsão espacial ou regularidade</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">plot</span>(<span class="kw">envelope</span>(<span class="dt">Y =</span> alea.ppp, <span class="dt">fun =</span> Lest, <span class="dt">nsim =</span> <span class="dv">99</span>), <span class="dt">main=</span><span class="st">&quot;Aleatório&quot;)</span>
<span class="st">plot(envelope(Y = uni.ppp, fun = Lest, nsim = 99), main=&quot;</span>Regular<span class="st">&quot;)</span>
<span class="st">plot(envelope(Y = clu.ppp, fun = Lest, nsim = 99), main=&quot;</span>Agregado<span class="st">&quot;)</span></code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-27-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exemplo</strong>: Verificando o padrão espacial de segunda ordem dos casos de homicíodos em POA/RS</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Convertendo para a class ppp</span>
<span class="kw">library</span>(spatstat)
<span class="co">#range(homic2[1])</span>
<span class="co">#range(homic2[2])</span>

w &lt;-<span class="st"> </span><span class="kw">as.owin</span>(<span class="kw">list</span>(<span class="dt">xrange=</span><span class="kw">range</span>(homic2<span class="op">$</span>x),<span class="dt">yrange=</span><span class="kw">range</span>(homic2<span class="op">$</span>y)))
w</code></pre>
<p>window: rectangle = [17472, 19073] x [165625, 168269] units</p>
<pre class="sourceCode r"><code class="sourceCode r">homic2.ppp &lt;-<span class="st"> </span><span class="kw">as.ppp</span>(homic2, w)
<span class="kw">plot</span>(homic2.ppp,<span class="dt">pch=</span><span class="dv">19</span>,<span class="dt">cex=</span><span class="fl">0.5</span>)
<span class="kw">polymap</span>(contorno.poa,<span class="dt">add=</span>T)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-28-1.png" width="672" style="display: block; margin: auto;" />
Note que o restangulo envolvente (<strong>bbox</strong>) foi feito com a coordenadas dos dados<br />
não do contorno de POA</p>
<p>Grafícos das Funções <em>K</em> , <em>G</em> e <em>L</em> dos homicíodos em POA/RS</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">plot</span>(<span class="kw">envelope</span>(<span class="dt">Y =</span> homic2.ppp, <span class="dt">fun =</span> Kest, <span class="dt">nsim =</span> <span class="dv">99</span>), <span class="dt">main=</span><span class="st">&quot;Funcao K&quot;</span>)
<span class="kw">plot</span>(<span class="kw">envelope</span>(<span class="dt">Y =</span> homic2.ppp, <span class="dt">fun =</span> Gest, <span class="dt">nsim =</span> <span class="dv">99</span>), <span class="dt">main=</span><span class="st">&quot;Funcao G&quot;</span>)
<span class="kw">plot</span>(<span class="kw">envelope</span>(<span class="dt">Y =</span> homic2.ppp, <span class="dt">fun =</span> Lest, <span class="dt">nsim =</span> <span class="dv">99</span>), <span class="dt">main=</span><span class="st">&quot;Funcao L&quot;</span>)</code></pre>
<p><img src="capitulo6_files/figure-html/unnamed-chunk-29-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Comente esses resultados!</p>
</div>
<div id="deteccao-de-cluster" class="section level2">
<h2><span class="header-section-number">1.11</span> Detecção de cluster</h2>
<ul>
<li><p>Definição (Knox): grupo de ocorrências geograficamente limitado em tamanho e concentração tais que seja improvável ocorrer por mero acaso.</p></li>
<li><p>São causas de cluster: fonte comum, contagiosidade.</p></li>
<li><p>Clusters são em geral espaço-temporais.</p></li>
<li><p>É importante considerar:</p>
<ul>
<li><p>Demais fatores de risco – sexo, idade;</p></li>
<li><p>Residência X outros locais;</p></li>
<li><p>Latência.</p></li>
</ul></li>
<li><p>Dois tipos básicos de testes:</p>
<ul>
<li><p><strong>Focados</strong>: testa-se a hipótese de excesso de casos ao redor de fonte suspeita, identificada antes de observar os dados;</p></li>
<li><p><strong>Genéricos</strong>: busca identificar áreas quentes, sem especificar quais e quantas.</p></li>
</ul></li>
<li><p>Hipóteses dos testes:</p>
<p><span class="math inline">\(H_0\)</span>: É ausência de cluster: completa aleatoriedade espacial (CSR).</p></li>
<li><p><strong>CSR</strong></p></li>
<li><p>Sendo:</p></li>
</ul>
<p><span class="math inline">\(n\)</span> são subdivisões da região do estudo,</p>
<p><span class="math inline">\(y_i\)</span> número de casos observados e <span class="math inline">\(E_i\)</span> esperados,</p>
<p><span class="math inline">\(\lambda\)</span> eventos por unidade de área (e tempo)</p>
<ul>
<li><p>Alternativas:</p>
<ul>
<li><p>Focados - <span class="math inline">\(\lambda\)</span> varia com a distância da fonte</p></li>
<li><p>Genéricos - existe regiões onde <span class="math inline">\(\lambda\)</span> é mais elevado</p></li>
</ul></li>
</ul>
<div id="testes-genericos-de-cluster" class="section level3">
<h3><span class="header-section-number">1.11.1</span> Testes Genéricos de Cluster</h3>
<ul>
<li><p><strong>Knox:</strong> Testa um número acima do esperado de pares de casos excessivamente próximos (segundo critério pré-estabelecido) no espaço e no tempo.</p></li>
<li><p><strong>Mantel:</strong> Distância no tempo e distância no espaço, se <span class="math inline">\(x\)</span> for 1 e <span class="math inline">\(y\)</span>
for 1, equivale ao teste de Knox.</p></li>
</ul>
<p><span class="math display">\[\sum \sum\limits_{i \neq j} x_{ij} y_{ij} \]</span></p>
<ul>
<li><strong>Cuzick-Edwards:</strong> Caso-controle onde a coincidência de casos vizinhos aumenta o peso, e a junção controle-controle ou caso-controle tem peso zero; este teste permite considerar a variação populacional.</li>
</ul>
</div>
<div id="fonte-especifica" class="section level3">
<h3><span class="header-section-number">1.11.2</span> Fonte Específica</h3>
<ul>
<li><p>Cluster ao redor de um ponto ou uma linha</p></li>
<li><p>Compara-se a ocorrência de no excessivo de “casos” em relação à população a partir de uma função de decaimento em relação à possível fonte</p></li>
</ul>
<p><span class="math display">\[\lambda (s) = \rho \lambda&#39;(s)f(h;\theta)\]</span></p>
<p><span class="math display">\[f(h;\theta) = 1 + \theta_1 e^{\theta_{2}h^2}\]</span></p>
<p>Sendo:</p>
<p><span class="math inline">\(\theta(s)\)</span> - estimativa do evento p/ unidade de área</p>
<p><span class="math inline">\(\rho\)</span> - parâmetro que indica a razão entre “casos” e “controles”</p>
<p><span class="math inline">\(\lambda&#39;(s)\)</span> - estimativa população p/ unidade de área</p>
<p><span class="math inline">\(f\)</span> - função da distância para a fonte</p>
<p><span class="math inline">\(θ\)</span> - parâmetros a estimar que descrevem como a incidência varia em torno da fonte</p>
</div>
</div>
<div id="exercicios-propostos" class="section level2">
<h2><span class="header-section-number">1.12</span> Exercícios Propostos</h2>
<ol style="list-style-type: decimal">
<li><p>Testar a CSR e explorar os Kernels para as causas de suicídio e acidentes de carro em POA/RS</p></li>
<li><p>Fazer a razão de kernel entre suicídios e acidentes de carro em POA/RS</p></li>
<li><p>Inspecionar o processo pontual de segunta ordem, utilizando as funções K, G e L para as causas de suicídio e acidentes de carro em POA/RS.</p></li>
</ol>
<div id="exercicios-resolvidos" class="section level4">
<h4><span class="header-section-number">1.12.0.1</span> Exercícios Resolvidos</h4>
<ul>
<li><a href="https://gitlab.procc.fiocruz.br/oswaldo/eco2019/raw/master/scripts/ex_cap6_padraoponto.r">Exercícios Padrões Pontuais</a></li>
</ul>
<p>ASSUNÇÃO, Renato M. Estatística espacial com aplicações em epidemiologia, economia e sociologia. São Carlos: Associação Brasileira de Estatística, v. 131, 2001.</p>
<p>DIGGLE, Peter J. et al. Statistical analysis of spatial point patterns. Academic press, 1983.</p>
<p>GATRELL, Anthony C. et al. Spatial point pattern analysis and its application in geographical epidemiology. Transactions of the Institute of British geographers, p. 256-274, 1996.</p>
<p>BADDELEY, Adrian , RUBAK, Ege, TURNER, Rolf Turner. Spatial Point Patterns: Methodology and Applications with R
Chapman and Hall/CRC 810 Pages. 1st Edition 2015.</p>
</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
