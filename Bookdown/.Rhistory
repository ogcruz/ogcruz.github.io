? in.out
plot(bnd,type="n")
plot(bnd,type="n")
bnd
grade
inside <- in.out(as.matrix(grade), as.matrix(contorno.xy))
inside
outside <- list(x=seq(caixa[1],caixa[3],length=TAM),
y=seq(caixa[2],caixa[4],length=TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x = outside$x
y = outside$y
newgam <- data.frame(XCoord=grade[,1],YCoord=grade[,2])
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred ,- predict(mod0,newdata=newgam, type="terms", terms="s(XCoord,YCoord)",se.fit=T)
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(XCoord,YCoord)",se.fit=T)
#
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
##############
################ Drawing
library(fields)
#cores <- gray(32:0/32)
#library(colorspace)
cores <- rev(heat_hcl(33, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.3)))
#cores <- gray(32:0/32)
library(colorspace)
cores <- rev(heat_hcl(33, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.3)))
cores <- diverge_hcl(20)
cores <- diverge_hcl(30, c = 100, l = c(50, 90), power = 2)
cores <- c("#053061","#2166ac","#4393c3","#92c5de","#d1e5f0","#f7f7f7","#fddbc7","#f4a582","#d6604d",
"#b2182b","#67001f")
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1)
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1)
polymap(pbdry,add=T,lwd=2)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
x <-  outside$x
y <-  outside$y
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
x
y
z
image(x,y,z, col=cores, asp=1, xlab="", ylab="", main="",axes=F)
image(x,y,z, asp=1, xlab="", ylab="", main="",axes=F)
z
image(z)
z
grade <- expand.grid(x=seq(caixa[1],caixa[3],length=TAM),y=seq(caixa[2],caixa[4],length=TAM))
inside <- in.out(grade, pbdry, bound=NULL)
caixa
outside <- list(x=seq(caixa[1],caixa[3],length=TAM),
y=seq(caixa[2],caixa[4],length=TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(gg,newdata=newgam, type="terms", terms="s(XCoord,YCoord)",se.fit=T)
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(XCoord,YCoord)",se.fit=T)
mod0
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
#
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
cores <- c("#053061","#2166ac","#4393c3","#92c5de","#d1e5f0","#f7f7f7","#fddbc7","#f4a582","#d6604d",
"#b2182b","#67001f")
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1)
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1)
polymap(pbdry,add=T,lwd=2)
grade <- expand.grid(x=seq(caixa[1],caixa[3],llength.out = TAM),y=seq(caixa[2],caixa[4],llengtlength.out = TAM))
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],lengtlength.out = TAM))
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],length.out = TAM))
inside <- in.out(grade, pbdry, bound=NULL)
inside <- in.out(as.matrix(grade), as.matrix(contorno.xy))
outside <- list(x=seq(caixa[1],caixa[3],length.out = TAM),
y=seq(caixa[2],caixa[4],length.out = TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
#
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
##############
################ Drawing
library(fields)
cores <- c("#053061","#2166ac","#4393c3","#92c5de","#d1e5f0","#f7f7f7","#fddbc7","#f4a582","#d6604d",
"#b2182b","#67001f")
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
image(z)
z
z
caixa
plot(grade)
TAM <- 50
caixa <- bbox(cont)
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],length.out = TAM))
plot(grade)
inside <- in.out(as.matrix(grade), as.matrix(contorno.xy))
inside
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
#
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
#
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
##############
################ Drawing
library(fields)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
x
dim(x)
length(x)
length(y)
TAM <- 50
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],length.out = TAM))
inside <- in.out(grade, pbdry, bound=NULL)
inside <- in.out(as.matrix(grade), as.matrix(contorno.xy))
outside <- list(x=seq(caixa[1],caixa[3],length.out = TAM),
y=seq(caixa[2],caixa[4],length.out = TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
#
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
cores <- c("#053061","#2166ac","#4393c3","#92c5de","#d1e5f0","#f7f7f7","#fddbc7","#f4a582","#d6604d",
"#b2182b","#67001f")
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1)
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1)
polymap(pbdry,add=T,lwd=2)
polymap(contorno.xy,add=T,lwd=2)
library(maptools)
library(splancs)
polymap(contorno.xy,add=T,lwd=2)
TAM <- 50
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],length.out = TAM))
? in.out
inside <- in.out(as.matrix(contorno.xy),as.matrix(grade))
outside <- list(x=seq(caixa[1],caixa[3],length.out = TAM),
y=seq(caixa[2],caixa[4],length.out = TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
#
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
TAM <- 400
#caixa <- bbox(cont)
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],length.out = TAM))
inside <- in.out(as.matrix(contorno.xy),as.matrix(grade))
outside <- list(x=seq(caixa[1],caixa[3],length.out = TAM),
y=seq(caixa[2],caixa[4],length.out = TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
#
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
##############
################ Drawing
library(fields)
cores <- c("#053061","#2166ac","#4393c3","#92c5de","#d1e5f0","#f7f7f7","#fddbc7","#f4a582","#d6604d",
"#b2182b","#67001f")
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1)
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1)
polymap(contorno.xy,add=T,lwd=2)
ticks <- seq(-0.8,0.5,0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
ticks <- seq(0.2,2.4,by=0.2)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
TAM <- 400
#caixa <- bbox(cont)
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],length.out = TAM))
inside <- in.out(as.matrix(contorno.xy),as.matrix(grade))
outside <- list(x=seq(caixa[1],caixa[3],length.out = TAM),
y=seq(caixa[2],caixa[4],length.out = TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
cores <- c("#053061","#2166ac","#4393c3","#92c5de","#d1e5f0","#f7f7f7","#fddbc7","#f4a582","#d6604d",
"#b2182b","#67001f")
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1)
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1)
polymap(contorno.xy,add=T,lwd=2)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(-0.8,0.5,0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
ticks <- seq(0.2,2.4,by=0.2)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(0.021,4.4,by=0.2)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1)
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1)
polymap(contorno.xy,add=T,lwd=2)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(-0.8,0.5,0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
ticks <- seq(0.021,4.4,by=0.2)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1,labels = '>1')
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1,labels = '>1')
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1,labels = '<1')
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1,labels = '>1')
polymap(contorno.xy,add=T,lwd=2)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(-0.8,0.5,0.2)
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1,labels = '<1')
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1,labels = '>1')
polymap(contorno.xy,add=T,lwd=2)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(-0.8,0.5,0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
ticks <- seq(0.021,4.4,by=0.2)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1,labels = '<1')
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1,labels = '>1')
polymap(contorno.xy,add=T,lwd=2)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(-0.8,0.5,0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
ticks <- seq(0.021,4.4,by=0.2)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1,labels = '<1')
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1,labels = '>1')
polymap(contorno.xy,add=T,lwd=2)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(-0.8,0.5,0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
ticks <- seq(0.021,4.4,by=0.2)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
z <- exp(matrix(gg.pred$se,TAM,TAM))
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
image(x,y,z,zlim=range(z, na.rm=T), asp=1, xlab="", ylab="", main="",axes=F)
? image.plot
library(splancs)
library(fields)
TAM <- 400
caixa <- st_bbox(contorno)
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],length.out = TAM))
contorno.xy <- as.data.frame(slot(slot(slot(as_Spatial(contorno),"polygons")[[1]],"Polygons")[[1]],"coords"))
inside <- in.out(as.matrix(contorno.xy),as.matrix(grade))
outside <- list(x=seq(caixa[1],caixa[3],length.out = TAM),
y=seq(caixa[2],caixa[4],length.out = TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
cores <- c("#053061","#2166ac","#4393c3","#92c5de","#d1e5f0","#f7f7f7","#fddbc7","#f4a582","#d6604d",
"#b2182b","#67001f")
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1,labels = '<1')
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1,labels = '>1')
splancs::polymap(contorno.xy,add=T,lwd=2)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(0,0.5,by=0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
#ticks <- seq(0.021,4.4,by=0.2)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
ticks <- seq(0,0.5,by=0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
library(splancs)
library(fields)
TAM <- 400
caixa <- st_bbox(contorno)
grade <- expand.grid(x=seq(caixa[1],caixa[3],length.out = TAM),y=seq(caixa[2],caixa[4],length.out = TAM))
contorno.xy <- as.data.frame(slot(slot(slot(as_Spatial(contorno),"polygons")[[1]],"Polygons")[[1]],"coords"))
inside <- in.out(as.matrix(contorno.xy),as.matrix(grade))
outside <- list(x=seq(caixa[1],caixa[3],length.out = TAM),
y=seq(caixa[2],caixa[4],length.out = TAM), z=matrix(rep(0,TAM^2),ncol=TAM) )
outside$z[inside] <- NA
x <-  outside$x
y <-  outside$y
newgam <- data.frame(X=grade[,1],Y=grade[,2])
gg.pred <- predict(mod0,newdata=newgam, type="terms", terms="s(X,Y)",se.fit=T)
gg.pred$fit[inside==F]<-NA
gg.pred$se.fit[inside==F]<-NA
z <- exp(matrix(gg.pred$fit,TAM,TAM))
## a very rough estimate of confidence intervals
z.inf <- exp(gg.pred$fit + (1.96 * gg.pred$se.fit))
z.sup <- exp(gg.pred$fit - (1.96 * gg.pred$se.fit))
z.inf <- matrix(z.inf,TAM,TAM)
z.sup <- matrix(z.sup,TAM,TAM)
cores <- c("#053061","#2166ac","#4393c3","#92c5de","#d1e5f0","#f7f7f7","#fddbc7","#f4a582","#d6604d",
"#b2182b","#67001f")
split.screen(rbind(c(0,.9,0,1), c(.9,1,0,1)))
screen(1)
image(x,y,z,zlim=range(z, na.rm=T), col=cores, asp=1, xlab="", ylab="", main="",axes=F)
#points(den$x_coord, den$y_coord, pch=19, col="blue", cex=0.1)
contour(x, y, z.inf, nlevels=1, add=T, col="blue", lwd=2, levels=1,cex=0.1,labels = '<1')
contour(x, y, z.sup, nlevels=1, add=T, col="red", lwd=2, levels=1,cex=0.1,labels = '>1')
splancs::polymap(contorno.xy,add=T,lwd=2)
screen(2) # The legend
range(z, na.rm=T) # to make a pretty legend
#ticks <- seq(0,0.5,by=0.2)
ticks <- quantile(na.omit(as.vector(z)),prob=seq(0,1,by=1/3))
ticks <- seq(0.021,4.4,by=0.25)
image.plot(zlim=range(z, na.rm=T), col=cores, axis.args=list(at=ticks, labels=ticks),legend.only=TRUE, smallplot=c(.1,.25, .15,.85), legend.width=3, legend.shrink=.8, horizontal=F)
kcasos.b750 <- density(dengue.ppp,750,diggle = TRUE)
razao <- kcasos.b750
razao$v <- (kcasos.b750$v / kpop$v)*1000
plot(razao,main='Razão de kernel casos/população')
contour(razao,add=T,levels=seq(0,25,by=5))
boxplot(as.numeric(razao$v),col='green',main='Boxplot da razão de kernel')
boxplot(nrow(casos.pt)/sum(popsetor$pop) * 1000))
boxplot(nrow(casos.pt)/sum(popsetor$pop) * 1000)
boxplot((casos.pt/popsetor$pop) * 1000)
boxplot((casos.pt/popsetor$pop))
casos.pt/popsetor$pop
casos.pt
casos.pt %>% group_by(ID_UNIDADE)
casos.pt %>% group_by(ID_UNIDADE) %>% n()
casos.pt %>% group_by(ID_UNIDADE) %>%
casos.pt %>% group_by(ID_UNIDADE) %>% summarise(casos=n())
casos.pt %>% group_by(ID_UNIDADE) %>% summarise(casos=n()) %>% left_join(popsetor,by=c('ID_UNIDADE'='ID'))
casos.pt %>% group_by(ID_UNIDADE) %>% summarise(casos=n()) %>% left_join(popsetor,by=c('ID_UNIDADE'='ID'))
casos.pt %>% group_by(ID_UNIDADE) %>% summarise(casos=n())
casos.pt %>% group_by(ID_UNIDADE) %>% summarise(casos=n()) %>% left_join(popsetor,by=c('ID_UNIDADE'='idsetor'))
casos.pt %>% group_by(ID_UNIDADE) %>% summarise(casos=n())
casos
plot(popsetor)
popsetor %>% st_within(casos.pt)
tail(popsetor %>% st_within(casos.pt))
tail(popsetor %>% st_contains(casos.pt)
)
popsetor %>% st_contains(casos.pt)
xxx <- popsetor %>% st_contains(casos.pt)
xxx
xxx[[1]]
sapply(xxx, length)
popsetor$casos <- sapply(xxx, length)
popsetor
popsetor$casos/popsetor$pop
(popsetor$casos/popsetor$pop)*1000
boxplot((popsetor$casos/popsetor$pop)*1000)
boxplot((popsetor$casos/popsetor$pop)*1000,col='green')
popsetor$taxa <- (popsetor$casos/popsetor$pop)*1000
plot(popsetor['taxa'])
ggplot(popsetor) +
geom_sf(aes(fill=pop)) +
geom_sf(data=casos.pt,color='white',size=0.7) +
theme_void()
p1 <- ggplot(popsetor) +
geom_sf(aes(fill=pop)) +
geom_sf(data=casos.pt,color='white',size=0.7) +
theme_void()
print(p1)
casos.pt %>% filter(CLASSI_FIN == 1)
confirm <- casos.pt %>% filter(CLASSI_FIN == 1)
Confirm <- casos.pt %>% filter(CLASSI_FIN == 1)
NaoConfirm <- casos.pt %>% filter(CLASSI_FIN != 1)
density(confirm,750,diggle = TRUE)
density(confirm,750)
dengue.ppp
view(dengue.ppp)
Confirm <- casos %>% filter(CLASSI_FIN == 1)
NaoConfirm <- casos %>% filter(CLASSI_FIN != 1)
Confirm.ppp <- ppp(Confirm$X,Confirm$Y,cont.w)
NaoConfirm.ppp <- ppp(NaoConfirm$X,NaoConfirm$Y,cont.w)
? kernrat
? desity
? densityfun.ppp
? density
Confirm <- casos %>% filter(CLASSI_FIN == 1)
NaoConfirm <- casos %>% filter(CLASSI_FIN != 1)
Confirm.ppp <- ppp(Confirm$X,Confirm$Y,cont.w)
NaoConfirm.ppp <- ppp(NaoConfirm$X,NaoConfirm$Y,cont.w)
