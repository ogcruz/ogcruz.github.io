alea.spp <- csr(caixa,300)
# Processo de poisson clusterizado
clu.spp <- pcp.sim(rho=20,m=40,s2=0.005, region.poly=caixa)
# rho= intensidade do processo de poisson "pai"(gerador)
# m=media
# s2=variancia
# Distribuicao regular
uni.spp <- jitter(gridpts(caixa,300),2)
# o comando jitter cria uma flutuacao aleatoria sobre os valores
# o comando gridpts gera uma grade regular
# 2 e' o fator de confusao adicionado ao grid regular
par(mfrow=c(1, 3))
plot(alea.spp, main="Aleatório")
plot(uni.spp, main="Regular")
plot(clu.spp, main="Agregado")
seed(9999)
set.seed(9999)
# Criando uma caixa envoltoria
caixa <- rbind(c(0,0),c(0,1),c(1,1),c(1,0),c(0,0))
# Simulando um processo espacial aletaorio
#csr significa "complete spatial randomness"
alea.spp <- csr(caixa,300)
# Processo de poisson clusterizado
clu.spp <- pcp.sim(rho=20,m=40,s2=0.005, region.poly=caixa)
# rho= intensidade do processo de poisson "pai"(gerador)
# m=media
# s2=variancia
# Distribuicao regular
uni.spp <- jitter(gridpts(caixa,300),2)
# o comando jitter cria uma flutuacao aleatoria sobre os valores
# o comando gridpts gera uma grade regular
# 2 e' o fator de confusao adicionado ao grid regular
par(mfrow=c(1, 3))
plot(alea.spp, main="Aleatório")
plot(uni.spp, main="Regular")
plot(clu.spp, main="Agregado")
W <- square(10)
Z <- quadrats(W, 4, 5)
plot(Z)
data(letterR)
plot(quadrats(letterR, 5, 7))
plot(quadrats(caixa, 5, 7))
W <- square(10)
Z <- quadrats(W, 4, 5)
plot(Z)
data(letterR)
plot(quadrats(letterR, 5, 7))
plot(quadrats(caixa, 5, 7))
quadrats(caixa, 5, 5)
quadrats(caixa, 4, 5)
library(spatstat)
aleatorioQ  <- as(alea.spp, "ppp")
quadrat.test(alea.spp, nx = 3, ny = 2)
data(swedishpines)
plot(swedishpines)
swedishpines
xy <- matrix(runif(40), ncol=2)
xy
pp <- as.ppp(xy, c(0,1,0,1))
pp
suic.ppp <- as.ppp(suic)
View(alea.spp)
suic.ppp <- as.ppp(alea.spp, c(0,1,0,1))
suic.ppp
aleatorioQ <- quadratcount(alea.ppp, nx = 4, ny = 4)
# Convertendo para a class ppp
alea.ppp <- as.ppp(alea.spp, c(0,1,0,1))
aleatorioQ <- quadratcount(alea.ppp, nx = 4, ny = 4)
plot(aleatorioQ, main="Aleatório")
plot(aleatorioQ, main="Aleatório")
plot(alea.spp, add = TRUE)
plot(aleatorioQ, main="Aleatório")
plot(alea.ppp, add = TRUE)
plot(aleatorioQ, main="Aleatório")
plot(aleatorioQ, main="Aleatório")
plot(alea.ppp, add = TRUE)
alea.ppp <- as.ppp(alea.spp, c(0,1,0,1))
# Convertendo para a class ppp
library(spatstat)
alea.ppp <- as.ppp(alea.spp, c(0,1,0,1))
uni.ppp <- as.ppp(uni.spp, c(0,1,0,1))
clu.ppp <- as.ppp(clu.ppp, c(0,1,0,1))
# Convertendo para a class ppp
library(spatstat)
alea.ppp <- as.ppp(alea.spp, c(0,1,0,1))
uni.ppp <- as.ppp(uni.spp, c(0,1,0,1))
clu.ppp <- as.ppp(clu.spp, c(0,1,0,1))
# Construindo os quadrantes
aleatorioQ <- quadratcount(alea.ppp, nx = 4, ny = 4)
regularQ <- quadratcount(uni.ppp, nx = 4, ny = 4)
agregadoQ <- quadratcount(clu.spp, nx = 4, ny = 4)
# Convertendo para a class ppp
library(spatstat)
alea.ppp <- as.ppp(alea.spp, c(0,1,0,1))
uni.ppp <- as.ppp(uni.spp, c(0,1,0,1))
clu.ppp <- as.ppp(clu.spp, c(0,1,0,1))
# Construindo os quadrantes
aleatorioQ <- quadratcount(alea.ppp, nx = 4, ny = 4)
regularQ <- quadratcount(uni.ppp, nx = 4, ny = 4)
agregadoQ <- quadratcount(clu.ppp, nx = 4, ny = 4)
par(mfrow=c(1, 3))
plot(aleatorioQ, main="Aleatório")
plot(alea.ppp, add = TRUE)
plot(regularQ, main="Regular")
plot(uni.ppp, add = TRUE)
plot(agregadoQ, main="Agregado")
plot(clu.ppp, add = TRUE)
quadrat.test(aleatorioQ)
quadrat.test(agregadoQ)
quadrat.test(regularQ)
quadrat.test(aleatorioQ)
set.seed(9999)
# Criando uma caixa envoltoria
caixa <- rbind(c(0,0),c(0,1),c(1,1),c(1,0),c(0,0))
# Simulando um processo espacial aletaorio
#csr significa "complete spatial randomness"
alea.spp <- csr(caixa,100)
# Processo de poisson clusterizado
clu.spp <- pcp.sim(rho=20,m=10,s2=0.005, region.poly=caixa)
# rho= intensidade do processo de poisson "pai"(gerador)
# m=media
# s2=variancia
# Distribuicao regular
uni.spp <- jitter(gridpts(caixa,100),2)
# o comando jitter cria uma flutuacao aleatoria sobre os valores
# o comando gridpts gera uma grade regular
# 2 e' o fator de confusao adicionado ao grid regular
par(mfrow=c(1, 3))
plot(alea.spp, main="Aleatório")
plot(uni.spp, main="Regular")
plot(clu.spp, main="Agregado")
# Convertendo para a class ppp
library(spatstat)
alea.ppp <- as.ppp(alea.spp, c(0,1,0,1))
uni.ppp <- as.ppp(uni.spp, c(0,1,0,1))
clu.ppp <- as.ppp(clu.spp, c(0,1,0,1))
# Construindo os quadrantes com as respectivas contagens
aleatorioQ <- quadratcount(alea.ppp, nx = 4, ny = 4)
regularQ <- quadratcount(uni.ppp, nx = 4, ny = 4)
agregadoQ <- quadratcount(clu.ppp, nx = 4, ny = 4)
par(mfrow=c(1, 3))
plot(aleatorioQ, main="Aleatório")
plot(alea.ppp, add = TRUE)
plot(regularQ, main="Regular")
plot(uni.ppp, add = TRUE)
plot(agregadoQ, main="Agregado")
plot(clu.ppp, add = TRUE)
quadrat.test(aleatorioQ)
quadrat.test(agregadoQ)
quadrat.test(regularQ)
# Analisando o efeito de primeira ordem: variacao da intensidade
# kernel quartico
alea.ker <- kernel2d(alea.spp,caixa,h0=.1,nx=100,ny=100)
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
ssi.ker <- kernel2d(ssi.spp,caixa,h0=.1,nx=100,ny=100)
# Analisando o efeito de primeira ordem: variacao da intensidade
# kernel quartico
alea.ker <- kernel2d(alea.spp,caixa,h0=.1,nx=100,ny=100)
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
uni.ker <- kernel2d(uni.spp,caixa,h0=.1,nx=100,ny=100)
par(mfrow=c(1, 3))
image(clu.ker, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T,pch=19,col=4)
image(alea.ker, col=topo.colors(100,rev=FALSE),  main="Aleatorio")
pointmap(alea.spp, add=T,pch=19)
image(uni.ker, col=topo.colors(100), main="Regular")
pointmap(uni.spp, add=T)
# Analisando o efeito de primeira ordem: variacao da intensidade
# kernel quartico
alea.ker <- kernel2d(alea.spp,caixa,h0=.1,nx=100,ny=100)
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
uni.ker <- kernel2d(uni.spp,caixa,h0=.1,nx=100,ny=100)
par(mfrow=c(1, 3))
image(clu.ker, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T,pch=19,col=4)
image(alea.ker, col=gray(32:0/32),  main="Aleatorio")
pointmap(alea.spp, add=T,pch=19, col=4)
image(uni.ker, col=gray(32:0/32), main="Regular")
pointmap(uni.spp, add=T,pch=19, col=4)
# Analisando o efeito de primeira ordem: variacao da intensidade
# kernel quartico
alea.ker <- kernel2d(alea.spp,caixa,h0=.1,nx=100,ny=100)
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
uni.ker <- kernel2d(uni.spp,caixa,h0=.1,nx=100,ny=100)
par(mfrow=c(1, 3))
image(alea.ker, col=gray(32:0/32),  main="Aleatorio")
pointmap(alea.spp, add=T,pch=19, col=4)
image(uni.ker, col=gray(32:0/32), main="Regular")
pointmap(uni.spp, add=T,pch=19, col=4)
image(clu.ker, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T,pch=19,col=4)
# Analisando o efeito de primeira ordem: variacao da intensidade
# kernel quartico
alea.ker <- kernel2d(alea.spp,caixa,h0=.1,nx=100,ny=100)
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
uni.ker <- kernel2d(uni.spp,caixa,h0=.1,nx=100,ny=100)
par(mfrow=c(1, 3))
image(alea.ker, col=gray(32:0/32),  main="Aleatorio")
pointmap(alea.spp, add=T,pch=19, col="red")
image(uni.ker, col=gray(32:0/32), main="Regular")
pointmap(uni.spp, add=T,pch=19, col="red")
image(clu.ker, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T,pch=19,col="red")
range(clu.ker$z)
range(alea.ker$z)
range(uni.ker$z)
clu.ker$z
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
image(clu.ker, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T)
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
clu.ker1 <- kernel2d(clu.spp,caixa,h0=.5,nx=100,ny=100)
clu.ker2 <- kernel2d(clu.spp,caixa,h0=.8,nx=100,ny=100)
par(mfrow=c(1, 3))
image(clu.ker, col=gray(32:0/32), main="Cluster - Tau = 0.1")
pointmap(clu.spp, add=T)
image(clu.ker1, col=gray(32:0/32), main="Cluster - Tau = 0.5")
pointmap(clu.spp, add=T)
image(clu.ker2, col=gray(32:0/32), main="Cluster - Tau = 0.8")
pointmap(clu.spp, add=T)
clu.ker <- kernel2d(clu.spp,caixa,h0=.05,nx=100,ny=100)
clu.ker1 <- kernel2d(clu.spp,caixa,h0=.2,nx=100,ny=100)
clu.ker2 <- kernel2d(clu.spp,caixa,h0=.5,nx=100,ny=100)
par(mfrow=c(1, 3))
image(clu.ker, col=gray(32:0/32), main="Cluster - Tau = 0.05")
pointmap(clu.spp, add=T)
image(clu.ker1, col=gray(32:0/32), main="Cluster - Tau = 0.2")
pointmap(clu.spp, add=T)
image(clu.ker2, col=gray(32:0/32), main="Cluster - Tau = 0.5")
pointmap(clu.spp, add=T)
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
image(clu.ker, col=gray(32:0/32), main="Cluster")
contour(clu.ker,add=T)
par(mfrow=c(1, 3))
image(alea.ker, col=gray(32:0/32),  main="Aleatorio")
contour(alea.ker,add=T)
image(uni.ker, col=gray(32:0/32), main="Regular")
contour(uni.ker,add=T)
image(clu.ker, col=gray(32:0/32), main="Cluster")
contour(clu.ker,add=T)
persp(clu.ker)
par(mfrow=c(1, 3))
persp(alea.ker)
persp(uni.ker)
persp(clu.ker)
par(mfrow=c(1, 3))
persp(alea.ker)
persp(uni.ker)
persp(clu.ker)
persp(clu.ker)
mse2d(clu.spp, caixa,nsmse=20,range=0.2)
data(bodmin)
Mse2d <- mse2d(as.points(bodmin), bodmin$poly, nsmse=50, range=8)
plot(Mse2d$h[5:50],Mse2d$mse[5:50], type="l")
clu.ker <- kernel2d(clu.spp,caixa,h0=.05,nx=100,ny=100)
clu.ker1 <- kernel2d(clu.spp,caixa,h0=.2,nx=100,ny=100)
clu.ker2 <- kernel2d(clu.spp,caixa,h0=.5,nx=100,ny=100)
par(mfrow=c(1, 3))
image(clu.ker, col=gray(32:0/32), main="Cluster - Tau = 0.1")
pointmap(clu.spp, add=T)
image(clu.ker1, col=gray(32:0/32), main="Cluster - Tau = 0.2")
pointmap(clu.spp, add=T)
image(clu.ker2, col=gray(32:0/32), main="Cluster - Tau = 0.5")
pointmap(clu.spp, add=T)
clu.ker <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
clu.ker1 <- kernel2d(clu.spp,caixa,h0=.2,nx=100,ny=100)
clu.ker2 <- kernel2d(clu.spp,caixa,h0=.5,nx=100,ny=100)
par(mfrow=c(1, 3))
image(clu.ker, col=gray(32:0/32), main="Cluster - Tau = 0.1")
pointmap(clu.spp, add=T)
image(clu.ker1, col=gray(32:0/32), main="Cluster - Tau = 0.2")
pointmap(clu.spp, add=T)
image(clu.ker2, col=gray(32:0/32), main="Cluster - Tau = 0.5")
pointmap(clu.spp, add=T)
plot(mse2d(clu.spp, caixa, nsmse=20,range=0.2))
Mse2d <- mse2d(clu.spp, caixa, nsmse=20,range=0.2)
plot(Mse2d$h[5:50],Mse2d$mse[5:50], type="l")
Mse2d <- mse2d(clu.spp, caixa, nsmse=20,range=0.2)
plot(Mse2d$h,Mse2d$mse, type="l")
clu.ker <- kernel2d(clu.spp,caixa,h0=.05,nx=100,ny=100)
clu.ker1 <- kernel2d(clu.spp,caixa,h0=.1,nx=100,ny=100)
clu.ker2 <- kernel2d(clu.spp,caixa,h0=.2,nx=100,ny=100)
par(mfrow=c(1, 3))
image(clu.ker, col=gray(32:0/32), main="Cluster - Tau = 0.1")
pointmap(clu.spp, add=T)
image(clu.ker1, col=gray(32:0/32), main="Cluster - Tau = 0.2")
pointmap(clu.spp, add=T)
image(clu.ker2, col=gray(32:0/32), main="Cluster - Tau = 0.5")
pointmap(clu.spp, add=T)
clu.ker <- kernel2d(clu.spp,caixa,h0=.05,nx=100,ny=100)
clu.ker1 <- kernel2d(clu.spp,caixa,h0=.2,nx=100,ny=100)
clu.ker2 <- kernel2d(clu.spp,caixa,h0=.5,nx=100,ny=100)
par(mfrow=c(1, 3))
image(clu.ker, col=gray(32:0/32), main="Cluster - Tau = 0.05")
pointmap(clu.spp, add=T)
image(clu.ker1, col=gray(32:0/32), main="Cluster - Tau = 0.2")
pointmap(clu.spp, add=T)
image(clu.ker2, col=gray(32:0/32), main="Cluster - Tau = 0.5")
pointmap(clu.spp, add=T)
Mse2d <- mse2d(clu.spp, caixa, nsmse=20,range=0.2)
plot(Mse2d$h,Mse2d$mse, type="l", ylab="h")
Mse2d <- mse2d(clu.spp, caixa, nsmse=20,range=0.2)
plot(Mse2d$h,Mse2d$mse, type="l", xlab="h")
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.05,h2 <- 0.6,nx=100,ny=100)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=0.6)
pointmap(alea.spp, add=T, col=4,pch=19,cex=0.6)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.05,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.1, h2 <- 0.6,nx=100,ny=100)
par(mfrow=c(1, 2))
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.05,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.1, h2 <- 0.6,nx=100,ny=100)
par(mfrow=c(1, 2))
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.05,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.1, h2 <- 0.6,nx=100,ny=100)
par(mfrow=c(1, 2))
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.05,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.2, h2 <- 0.2,nx=100,ny=100)
par(mfrow=c(1, 2))
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.2,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.1, h2 <- 0.1,nx=100,ny=100)
par(mfrow=c(1, 2))
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.1,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.1, h2 <- 0.2,nx=100,ny=100)
par(mfrow=c(1, 2))
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.1,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.1, h2 <- 0.3,nx=100,ny=100)
par(mfrow=c(1, 2))
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.1,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.2, h2 <- 0.2,nx=100,ny=100)
par(mfrow=c(1, 2))
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.1,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.2, h2 <- 0.2,nx=100,ny=100)
par(mfrow=c(1, 2))
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.2,nx=100, ny=100)
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=1)
pointmap(alea.spp, add=T, col=4,pch=19,cex=1)
clu.ker2 <- kernel2d(clu.spp, caixa,h0=0.2,nx=100, ny=100)
clualea.ratio <- kernrat(clu.spp, alea.spp,caixa, h1 <- 0.2, h2 <- 0.2,nx=100,ny=100)
par(mfrow=c(1, 2))
image(clu.ker2, col=gray(32:0/32), main="Cluster")
pointmap(clu.spp, add=T, col=2,pch=19,cex=0.8)
image(clualea.ratio, col=gray(32:0/32), main="Razao Cluster/Aleatorio")
pointmap(clu.spp, add=T, col=2,pch=19,cex=0.8)
pointmap(alea.spp, add=T, col=4,pch=19,cex=0.8)
### testes de cluster
plot(khat(clu.spp,caixa,s=seq(0,1,0.05),newstyle=FALSE,checkpoly=TRUE))
clu.ppp <- as.ppp(clu.spp, W=c(0,1,0,1))
plot(Kest(clu.ppp,correction="border"))
plot(Lest(clu.ppp))
grade <-  GridTopology(cellcentre.offset=c(17393,164998),cellsize=c(10,10),cells.dim=c(239,345))
## selecao de largura de banda no olho
polymap(contorno.poa)
pointmap(homic2.spp,add=T)
## seleção de largura de banda por mínimos quadrados
xx <- mse2d(homic2.spp, contorno.poa,nsmse=50,range=100)
plot(xx$h, xx$mse)
homic.ker5 <- spkernel2d(homic2.spp, contorno.poa, h0=50, grd=grade)
homic.ker10 <- spkernel2d(homic2.spp, contorno.poa, h0=100, grd=grade)
homic.ker15 <- spkernel2d(homic2.spp, contorno.poa, h0=150, grd=grade)
homic.ker20 <- spkernel2d(homic2.spp, contorno.poa, h0=200, grd=grade)
df <- data.frame(ker5=homic.ker5, ker10=homic.ker10, ker15=homic.ker15,
ker20=homic.ker20)
kernels <- SpatialGridDataFrame(grade,data=df)
spplot(kernels,col.regions=terrain.colors(16),cuts=15)
## função K
poa.gpc <- read.polyfile("contpoa.gpc")
## construindo a grade de interpolação
range(contorno.poa[,1])
range(contorno.poa[,2])
grade <-  GridTopology(cellcentre.offset=c(17393,164998),cellsize=c(10,10),cells.dim=c(239,345))
## selecao de largura de banda no olho
polymap(contorno.poa)
pointmap(homic2.spp,add=T)
# procure olhando nas coordenadas qual seria uma distancia "razoavel")
# observe que de um extremo a outro do mapa temos 2390 (na horizontal). Entao uma distancia razoável seria...
## construindo a grade de interpolação
range(contorno.poa[,1])
range(contorno.poa[,2])
grade <-  GridTopology(cellcentre.offset=c(17393,164998),cellsize=c(10,10),cells.dim=c(239,345))
## selecao de largura de banda no olho
polymap(contorno.poa)
pointmap(homic2.spp,add=T,col=2,pch=19,cex=0.7)
# procure olhando nas coordenadas qual seria uma distancia "razoavel")
# observe que de um extremo a outro do mapa temos 2390 (na horizontal). Entao uma distancia razoável seria...
## seleção de largura de banda por mínimos quadrados
xx <- mse2d(homic2.spp, contorno.poa,nsmse=50,range=100)
plot(xx$h, xx$mse,  type="l", xlab="h",  ylab="Mse")
homic.ker5 <- spkernel2d(homic2.spp, contorno.poa, h0=50, grd=grade)
homic.ker10 <- spkernel2d(homic2.spp, contorno.poa, h0=100, grd=grade)
homic.ker15 <- spkernel2d(homic2.spp, contorno.poa, h0=150, grd=grade)
homic.ker20 <- spkernel2d(homic2.spp, contorno.poa, h0=200, grd=grade)
df <- data.frame(ker5=homic.ker5, ker10=homic.ker10, ker15=homic.ker15,
ker20=homic.ker20)
kernels <- SpatialGridDataFrame(grade,data=df)
spplot(kernels,col.regions=terrain.colors(16),cuts=15)
par(mfrow=c(1, 3))
plot(Gest(ale.ppp),main="Aleatório")
par(mfrow=c(1, 3))
plot(Gest(alea.ppp),main="Aleatório")
plot(Gest(uni.ppp), main="Regular")
plot(Gest(lu.ppp), main="Agregado")
par(mfrow=c(1, 3))
plot(Gest(alea.ppp),main="Aleatório")
plot(Gest(uni.ppp), main="Regular")
plot(Gest(clu.ppp), main="Agregado")
aleatorioK <- Kest(alea.ppp)
regularK <- Kest(uni.ppp)
agregadoK <- Kest(clu.ppp)
par(mfrow=c(1, 3))
plot(aleatorioK,main="Aleatório")
plot(regularK, main="Regular")
plot(agregadoK, main="Agregado")
aleatorioL <- Lest(alea.ppp)
regularL <- Lest(uni.ppp)
agregadoL <- Lest(clu.ppp)
par(mfrow=c(1, 3))
plot(aleatorioL,main="Aleatório")
plot(regularL, main="Regular")
plot(agregadoL, main="Agregado")
khat(alea.ppp, caixa)
Ghat(alea.ppp, tpe.s)
Ghat(alea.ppp)
Ghat(alea.spp)
Ghat(aleatorioK)
Ghat(acid)
Ghat(acid, contorno.poa)
qX <- quadratcount(alea.ppp, tess=B)
qX <- quadratcount(alea.ppp, tess=caixa)
qX <- quadratcount(alea.ppp, tess=tess)
qX <- quadratcount(alea.ppp)
qX
qX <- quadratcount(split(contorno.poa))
E <- envelope(cells, aleatorioK, nsim = 39, rank = 1)
E <- envelope(alea.ppp, aleatorioK, nsim = 39, rank = 1)
View(swedishpines)
View(suic.ppp)
plot(density(swedishpines, 10))
plot(density(alea.ppp, 10))
plot(density(alea.ppp, 0.1))
K <- Kest(swedishpines)
plot(K)
E <- envelope(Y = swedishpines, fun = Kest, nsim = 39)
E <- envelope(Y = alea.ppp, fun = Kest, nsim = 39)
plot(E)
par(mfrow=c(1, 3))
plot(envelope(Y = alea.ppp, fun = Kest, nsim = 39), main="Aleatório")
plot(envelope(Y = uni.ppp, fun = Kest, nsim = 39), main="Regular")
plot(envelope(Y = clu.ppp, fun = Kest, nsim = 39), main="Agregado")
par(mfrow=c(1, 3))
plot(envelope(Y = alea.ppp, fun = Kest, nsim = 39), main="Aleatório")
plot(envelope(Y = uni.ppp, fun = Kest, nsim = 39), main="Regular")
plot(envelope(Y = clu.ppp, fun = Kest, nsim = 39), main="Agregado")
par(mfrow=c(1, 3))
plot(envelope(Y = alea.ppp, fun = Lest, nsim = 39), main="Aleatório")
plot(envelope(Y = uni.ppp, fun = Lest, nsim = 39), main="Regular")
plot(envelope(Y = clu.ppp, fun = Lest, nsim = 39), main="Agregado")
par(mfrow=c(1, 3))
plot(envelope(Y = alea.ppp, fun = Gest, nsim = 39), main="Aleatório")
plot(envelope(Y = uni.ppp, fun = Gest, nsim = 39), main="Regular")
plot(envelope(Y = clu.ppp, fun = Gest, nsim = 39), main="Agregado")
data(bei)
bei
quadrat.test(bei, tess = V)
