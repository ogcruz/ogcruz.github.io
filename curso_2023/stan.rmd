
## Usando o rstan para modelagem de Olinda

### Introdução

Esse é uma pequena demostração de como o *stan* permite realizar Inferencia Bayesiana no **R**. 
Vamos ajustar um modelo espacial do tipo *CAR* para dos dados de Olinda.

Em primeiro lugar vamos carregar as bibliotecas a serem utilizadas e definir uma função auxiliar!

```{r message=FALSE,warning=FALSE,results='hide'}
library(sf)
library(rstan)
library(spdep)
library(ggplot2)

# opções para o Stan
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

rescale <- function(x) {(x - mean(x))/(quantile(x,0.975) - quantile(x,0.025))}
 
```

Antes de mais nada como na aula anterior vamos baixar o *ZIP* contendo os arquivos no formato **shape** e ler os setores de Olinda no formato *sf* 
```{r, echo=T, warning=FALSE, results='hide', message = FALSE, out.width = "100%", fig.align = "center"}

#opções para o Windows não se perder
options(download.file.method='libcurl',url.method='libcurl')

#local dos dados na rede
local <- 'https://gitlab.procc.fiocruz.br/oswaldo/eco2019/raw/master/dados/'

tmpdir <- tempdir()
download.file(paste0(local,'olinda.zip'),
              destfile = paste0(tmpdir,'/olinda.zip'))

unzip(zipfile = paste0(tmpdir,'/olinda.zip'),exdir = tmpdir)
dir(tmpdir)

olinda.sf <- read_sf(paste0(tmpdir,'/olinda.shp'), crs = 5535)
olinda.sp <- as_Spatial(olinda.sf)
```

Criando a matriz de vizinhaça por contiguidade.

```{r, echo=T, warning=FALSE, results='markdown', message = FALSE, out.width = "80%", fig.align = "center"}
viz <- poly2nb(olinda.sf,snap=0.0002)
#pesos.viz <- nb2listw(viz)
viz
```


```{r, echo=T, warning=FALSE, results='markdown', message = FALSE, out.width = "80%", fig.align = "center"}
plot(olinda.sp)
plot(viz,coords=coordinates(olinda.sp),add=TRUE,pch=16,col='darkred')
```


```R
data {
   int N;
   vector[N] x;
   vector[N] y;
   matrix<lower=0>[N,N] W;
   vector<upper=1>[N] e;
   matrix<lower=0,upper=1>[N,N] I;
 }
 
 parameters {
   real beta;
   real<lower=0,upper=100> alpha;
   real<lower = 0> sigma;
   real<lower=-1,upper=1> lambda;
 }
 
 
 
 model {
   y ~ multi_normal_prec(alpha + x * beta,  crossprod(I - lambda * W)/(sigma*sigma));
 }
 
```



```{r results='markdown'}
set.seed(34256)
x <- olinda.sf$DEPRIV
y <- (olinda.sf$CASES / olinda.sf$POP)*10000
N <- nrow(olinda.sf)
I <- diag(N)
W <- nb2mat(viz)
e <- rep(1,N)

dados <- list(N=N,x=x,y=y,I=I,W=W,e=e)

car_olinda <- stan('olinda_car.stan',data=dados)
car_olinda
stan_dens(car_olinda)
```

```{r}
traceplot(car_olinda)
traceplot(car_olinda,pars=c('alpha','beta','lambda'),inc_warmup=TRUE,ncol=3)
car_olinda_df <- as.data.frame(car_olinda)
ggplot(car_olinda_df,aes(x=lambda,y=beta)) + 
  geom_point(alpha=0.4,col='indianred') +
  geom_density2d(col='darkblue')
```

## Coeficiente variando no espaço

```R 

data {
   int N;
   vector[N] x;
   vector[N] y;
   matrix<lower=0>[N,N] W;
   vector<upper=1>[N] e;
   matrix<lower=0,upper=1>[N,N] I;
 }
 
 
 parameters {
   vector[N] beta;
   real<lower=0,upper=100> alpha;
   real mbeta;
   real<lower = 0> sigma;
   real<lower = 0> sigma_b;
   real<lower=-1,upper=1> lambda;
   real<lower=-1,upper=1> lambda_b;
 }
 
 
 
 model {
   beta ~ multi_normal_prec(e * mbeta,  tcrossprod(I - lambda_b * W)/(sigma_b*sigma_b));
   y ~ multi_normal_prec(alpha + x .* beta,  tcrossprod(I - lambda * W)/(sigma*sigma));
 }
 
```

Modelando com betas variando no espaço

```{r, results='markdown',comment=NA}

spatvar_olinda <- stan('spat_vari.stan',data=dados)
spatvar_olinda

```


```{r}
traceplot(spatvar_olinda)
#traceplot(spatvar_olinda,pars=c('alpha','beta','lambda'),inc_warmup=TRUE,ncol=3)
#spatvar_olinda_df <- as.data.frame(spatvar_olinda)
#ggplot(spatvar_olinda_df,aes(x=lambda,y=beta)) + 
#  geom_point(alpha=0.4,col='indianred') +
#  geom_density2d(col='darkblue')
save.image("~/tmp/olinda_stan.RData")
```

## referencias
[Stan DOC](https://mc-stan.org/docs/2_20/stan-users-guide/index.html)
[ICAR](https://mc-stan.org/users/documentation/case-studies/icar_stan.html)