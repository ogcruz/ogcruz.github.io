
```{r,echo=FALSE,message=FALSE,warning=FALSE}
library(knitr)
library(pander)
# Set so that long lines in R will be wrapped:
opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=TRUE)

```

# Exemplo de Analise Espacial

## Exemplo com os dados de dengue em Dourados/MS

Nesta aula serão utilizados os dados da monografia de Isis Rodrigues Reitman, apresentada ao Curso de Geografia da Faculdade de Ciências Humanas da Universidade Federal da Grande Douradosos/MS, em março de 2013. O título da monografia é "DISTRIBUIÇÃO ESPACIAL DOS CASOS DE DENGUE NO PERÍMETRO URBANO DE DOURADOS-MS E SUA RELAÇÃO COM OS FATORES SOCIOAMBIENTAIS E POLÍTICOS"

**ATENÇÃO               ATENÇÃO                    ATENÇÃO**

Devido a maneira que o Windows acessa as **url** usando a internet é necessario mudar a opção *default* dele para que possa usar apropiadamenet os recursos https, ftps, etc... A linha abaixo deve ser utilizanda antes de usar as funções que acessam esse tipo de recurso.

```R

options(download.file.method='libcurl',url.method='libcurl')

```

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

library(readr)
library(tidyverse)
library(sf)
library(maptools)
library(spatstat)
library(tmap)

```

Lendo a tabela da população por setor censitário e baixando os shapes files do contorno e por setor censitário de Dourados/MS

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

local <- 'https://gitlab.procc.fiocruz.br/oswaldo/eco2019/raw/master/dados/'
pop2010 <- read_csv(paste0(local,'pop2010.csv'))

tmpdir <- tempdir()
download.file(paste0(local,'setores_dourados.zip'),
              destfile = paste0(tmpdir,'/dourados.zip'))

unzip(zipfile = paste0(tmpdir,'/dourados.zip'),exdir = tmpdir)
dir(tmpdir)

setor.sf <- read_sf(paste0(tmpdir,'/Setor_UTM_SIRGAS.shp'), crs = 31981)
contorno.sf <- read_sf(paste0(tmpdir,'/contorno.shp'), crs = 31981)

```

Fazendo um join com as tabelas com os setores censitários + popoulação

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

setor.sf <- setor.sf %>% mutate (idsetor = as.numeric(CD_GEOCODI)) %>% inner_join(pop2010,by='idsetor')

```

```
[1] "contorno.dbf"                                     "contorno.sbn"                                    
[3] "contorno.sbx"                                     "contorno.shp"                                    
[5] "contorno.shx"                                     "dourados.zip"                                    
[7] "Setor_UTM_SIRGAS.dbf"                             "Setor_UTM_SIRGAS.prj"                            
[9] "Setor_UTM_SIRGAS.sbn"                             "Setor_UTM_SIRGAS.sbx"                            
[11] "Setor_UTM_SIRGAS.shp"                             "Setor_UTM_SIRGAS.shx"                            
```


- Lendo e plotando os casos de dengue georreferenciados em Dourados/MS

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

casos <- read_csv(paste0(local,'dengue_dourados.csv'))
casos.sf <- st_as_sf(casos, coords = c("X", "Y"), crs = 31981)

ggplot(setor.sf) + 
  geom_sf(fill = 'white', color='black') +
  geom_sf(data=casos.sf, color='red',size=1) +
  theme_void()

```

- Lendo e plotando os os pontos de coleta de lixo georreferenciados em Dourados/MS

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

lixo <- read_csv2('~/Documentos/cursos_ecologicos_2019/Bookdown/dados/lixo_dourados.csv')
lixo.sf <- st_as_sf(lixo, coords = c("X", "Y"), crs = 31981)


ggplot(setor.sf) + 
  geom_sf(fill = 'white', color = 'black') +
  geom_sf(data=lixo.sf,color='blue',size=1) +
  theme_void()

```

Como podemos observar, existem alguns pontos de coleta de lixo fora do contorno de Dourados/MS. Uma forma de ficarmos só com os pontos dentro do polígono é utilizando o comando *st_intersection*.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

lixo2.sf <- st_intersection(contorno.sf, lixo.sf)
# ou lixo2.sf <- st_intersection(setor.sf, lixo.sf)

ggplot(setor.sf) + 
  geom_sf(fill = 'white', color = 'black') +
  geom_sf(data=lixo2.sf,color='blue',size=1) +
  theme_void()

```


Verificando as paletas de cores.


```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

library(RColorBrewer)
display.brewer.all()

```

Utilizando as informações dos casos (pontos) + do lixo (ponto) + população de cada setor censitário (mapa temático)

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

ggplot(setor.sf) + 
  geom_sf(aes(fill=pop)) + 
  geom_sf(data=casos.sf,color='red',size=0.7, aes(colour = "Caso"), 
          show.legend = "point") +
  geom_sf(data=lixo2.sf,color='salmon',size=1, aes(colour = "Lixo"), 
          show.legend = "point") +
  scale_fill_distiller(palette ="PuBu", direction = 1) +
  scale_colour_manual(values = c("Caso" = "red", "Lixo" = "slamon")) +
  theme_minimal()


```

Iremos agora construir buffers de 500m de distância ao redor de cada ponto de coleta de lixo. Isso é interessante para verificar se os casos de dengue ocorrem em um raio de até 500m de distância dos pontos de coleta de lixo. Ou seja, a pergunta é, será que a distância dos pontos de coeta de lixo influenciam a ocorrência do caso de dengue ?
  
  **Buffers:** São polígonos que contornam um objeto a uma determinada distância. Sua principal função é materializar os conceitos de "perto" e "longe".

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

lixo_buffer <- st_buffer(lixo2.sf, 500) 

ggplot(setor.sf) + 
  geom_sf(aes(fill=pop)) + 
  geom_sf(data=lixo_buffer,color='gray', fill = "transparent", size=0.4) +
  geom_sf(data=casos.sf, color='red',size=0.7) +
  scale_fill_distiller(palette ="PuBu", direction = 1) +
  scale_colour_manual(values = c("Caso" = "red", "Lixo" = "slamon")) +
  theme_minimal()


```

Represntando os casos e o lixo de forma interativa.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

tm_shape(setor.sf) +  tm_borders("black") +
  tm_shape(casos.sf) + tm_dots("red") +
  tm_shape(lixo.sf) + tm_dots("green") +
  tm_shape(lixo_buffer) + tm_borders("blue") +
  tmap_mode("view")

```

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

## conta casos por setor 
casos.sf$contador <- 1 
casos <- setor.sf %>%  
  st_join(casos.sf) %>% 
  filter(CLASSI_FIN == 1) %>%  ## seleciona somente os casos confirmados
  group_by(ID) %>% 
  summarise(casos = sum(contador))

st_geometry(casos) <- NULL  ## remove atributos de geometria

## numero de depositos de Lixo por setor 
lixo.sf$contador <- 1 

lixo <- setor.sf %>%  
  st_join(lixo.sf) %>% 
  group_by(ID) %>% 
  summarise(lixo = sum(contador))

st_geometry(lixo) <- NULL ## remove atributos de geometria

# Inserindo as contagens dos casos e de pontos de coleta de lixo no atributo com a geometria.
setor.sf <- setor.sf %>% 
  left_join(lixo,by = 'ID') %>% 
  left_join(casos,by = 'ID') 

```

Plotando o mapa temático dos casos por setor censitário 

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

plot(setor.sf['casos'])

```

Plotando o mapa temático dos pontos de coleta de lixo por setor censitário 

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

plot(setor.sf['lixo'])

```

Calculando a taxa de incidência e plotando o mapa temático dos pontos de coleta de lixo por setor censitário 

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

setor.sf$tx <- (setor.sf$casos/setor.sf$pop) * 1000
setor.sf$tx[is.na(setor.sf$tx)] <- 0 # Transformando os missings em zero

summary(setor.sf$tx)

```


```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

library(wesanderson)
pal <- wes_palette("Moonrise3", 20, type = "continuous")

ggplot(setor.sf) + 
  geom_sf(aes(fill = tx), color = 'black') +
  scale_fill_gradientn(colours = pal) +
  ggtitle("Taxa de incidência de Dengue") + 
  theme_void()

```

## Kernel por atributos

Vamos plotar o kernel por atributos referente a taxa de incidência de dengue em Dourados/MS.

Primeiramente é necessário dissolver os poligonos em formato *sf* para obter o contorno.
Nesse caso queremos preservar o atributo *AREA*
  
```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

dourados.contorno <- st_union(setor.sf)
plot(dourados.contorno)

dourados.w <- as.owin(as_Spatial(dourados.contorno)) #

```

Extraindo os centróidas dos polígonos em Dourados/MS.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

centroides <- st_centroid(st_geometry(setor.sf))

# Transformando em os centróides em formato sp
centroides.sp <- as.data.frame(as_Spatial(centroides))
names(centroides.sp) <- c('X','Y')

plot(centroides.sp)

```

Colocando os pontos no formato *sp*
  
```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

centroides.ppp <- ppp(centroides.sp$X,centroides.sp$Y, dourados.w)

plot(centroides.ppp,pch=19,cex=0.5)

```

Fazendo o kernel por atributo da taxa de detecção

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

kernel.tx <- density(centroides.ppp, 500, weights = setor.sf$tx, scalekernel = TRUE)
plot(kernel.tx)

```

Construindo a matriz de vizinhança para verificar a autocorrelação espacial.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

library(spdep)
viz <- poly2nb(setor.sf)
viz 

```

Iremos precisar da coordenadas dos centróides 

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

setor.sp <- as(setor.sf, 'Spatial') # convertendo em formato sp
coord <- coordinates(setor.sp) # coordenadas dos centroidas dos poligonos de dourados
class(setor.sp)

```

## Matriz de Vizinhança


Iremos precisar da coordenadas dos centróides 

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

setor.sp <- as(setor.sf, 'Spatial') # convertendo em formato sp
coord <- coordinates(setor.sp) # coordenadas dos centroidas dos poligonos de dourados
class(setor.sp)

```

## Matriz de Vizinhança

Verificando a malha de conectividade da vizinhança de Dourados/MS

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

viz.sf <- as(nb2lines(viz, coords = coord), 'sf')
viz.sf <- st_set_crs(viz.sf, st_crs(setor.sf))

# Plota o grafo de conectividade por contiguidade
mapa.viz <- ggplot(setor.sf) + 
  geom_sf(fill = 'salmon', color = 'white') +
  geom_sf(data = viz.sf) +
  theme_minimal() +
  ggtitle("Vizinhança por \n conectividade") +
  ylab("Latitude") +
  xlab("Longitude")
mapa.viz

```

## Autocorrelação Espacial

Obtendo a correlação da taxa de incidência de dengue Dourados/MS

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

pesos.viz <- nb2listw(viz)
moran.test(setor.sf$tx, pesos.viz)

```

Plotando o correlograma

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

correl <- sp.correlogram(viz, setor.sf$tx, order = 8, method = "I")
correl

```

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

plot(correl)

```

Mapeando os polígonos que tiveram os p-valores mais significativos no Moran Local.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

setor.sf$pval <- localmoran(setor.sf$tx, pesos.viz)[,5]

tm_shape(setor.sf) + 
  tm_polygons(col='pval', title="p-valores", breaks=c(0, 0.01, 0.05, 0.10, 1), border.col = "white", palette="-Oranges") +
  tm_scale_bar(width = 0.15) 

```

Moran Local (Lisa Map) da taxa de incidência Dourados/MS

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

resI <- localmoran.sad(lm(setor.sf$tx ~ 1), 1:length(viz), viz, style = "W")
summary(resI)[1:10,]

```

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

setor.sf$MoranLocal <- summary(resI)[,1] 

library(scales)

ggplot(setor.sf) + 
  geom_sf(aes(fill = MoranLocal), color = 'black') +
  scale_fill_gradientn(colours=c("blue", "white", "red"), 
                       values=rescale(c(min(setor.sf$MoranLocal), 0, max(setor.sf$MoranLocal))), guide="colorbar") + 
  ggtitle("Moran local") + 
  theme_void()

```

## Modelos Linear, CAR e GWR

Ajustando o modelo de regressão linear simples.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

setor.sf$lixo[is.na(setor.sf$lixo)] <- 0 # Transformando os missings em zero

dourados.lm <- lm(tx ~ lixo, data=setor.sf)
summary(dourados.lm)

```

Checando os residuos para verificar a presença de autocorrelação.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

dourados.lm$lmresid<-residuals(dourados.lm)
moran.test(dourados.lm$lmresid, pesos.viz)

```

Ajustando o modelo CAR.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

dourados.car<-errorsarlm(tx ~ lixo, data=setor.sf, listw=pesos.viz)
summary(dourados.car)

```

Checando os residuos para verificar a presença de autocorrelação.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

dourados.car$carresid<-residuals(dourados.car)
moran.test(dourados.car$carresid, pesos.viz)

```

Ajustando o modelo GWR

Precisamos estimar a largura de banda **"ideal"** para o *kernel*
  
```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

# Biblioteca para ajustar o  modelos GWR
library(spgwr)
GWRbanda <- gwr.sel(tx ~ lixo, data=setor.sf, coords=cbind(centroides.sp$X,centroides.sp$Y) , adapt=T) 
GWRbanda

```


```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

dourados.gwr = gwr(tx ~ lixo, data=setor.sf, coords=cbind(centroides.sp$X,centroides.sp$Y), adapt=GWRbanda, hatmatrix=TRUE, se.fit=TRUE) 

dourados.gwr

```

Colocando a saída do modelo dentro de um dataframe.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

results<-as.data.frame(dourados.gwr$SDF)
head(results)

```

Verificando a distribuição dos coeficientes de regressão para a variável **lixo**
  
```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

hist(results$lixo)
abline(v = median(results$lixo), col="red")

```

Verificando a distribuição dos **localR2**
  
```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

hist(results$localR2)
abline(v =median(results$localR2), col="blue")

```

Incorporando alguns parâmetros de saída do modelo na tabela *olinda.sf*
  
```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

setor.sf$coef.lixo<-results$lixo
setor.sf$localR2<-results$localR2
setor.sf$pred.gwr<-results$pred

```

Definindo as paletes de cores para a construção dos mapas.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

library(RColorBrewer)
display.brewer.all()

pal <- brewer.pal(n = 10, name = "BuPu")

```

Mapa dos coeficientes de regressão para a variável **lixo**
  
```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

map.lixo <- ggplot(setor.sf) + 
  geom_sf(aes(fill = coef.lixo), color = 'black') +
  scale_fill_gradientn(colours = pal) +
  ggtitle("Distribuição dos coef. var. lixo") + 
  theme_void()
map.lixo

```


Checando os residuos para verificar a presença de autocorrelação para o modelo GWR.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

# Calculando os resíduos para o modelo GWR
results$residuos <- setor.sf$tx - results$pred

moran.test(results$residuos, pesos.viz)

```

Mapeando os coeficientes de regressão para a variável **lixo** por significancia através do teste de *wald*
  
```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

# Calculando a estatística de wald
setor.sf$wald.teste <- abs(results$lixo/results$lixo_se)
# Dicotomizando a estatística de wald
setor.sf$wald.teste <- ifelse(setor.sf$wald.teste < 2, 0, 1)


map.wald <- ggplot(setor.sf) + 
  geom_sf(aes(fill = factor(wald.teste)), color = 'black') +
  scale_fill_manual(values = c("white", "purple"), labels=c("< 2", ">= 2"), name='Wald') +
  ggtitle("Coef. lixo significativos") + 
  theme_void()


library(gridExtra)
grid.arrange(map.lixo, map.wald, ncol=2)

```


Mapa dos coeficientes de determinação regionalizados ($R^2$ local).

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

ggplot(setor.sf) + 
  geom_sf(aes(fill = localR2), color = 'black') +
  scale_fill_gradientn(colours = pal) +
  ggtitle("R² local") + 
  theme_void()

```

Verificando a distribuição dos preditos.

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

histdens <- function(x,titulo='') {
 densi  <- density(x)
 xli  <- range(densi$x)
 yli  <- range(densi$y)
 hist(x,col="red",probability = T,xlim = xli,ylim = yli,main=titulo)
 lines(densi,lwd=2)
 abline(v=median(x),lwd=4,col=4,lty=2)
}

attach(mtcars)
par(mfrow=c(2,2))

hist.tx <-  histdens(setor.sf$tx, "Tx Bruta")
hist.lm <-  histdens(dourados.lm$fitted.values, "Pred LM")
hist.car <-  histdens(dourados.car$fitted.values, "Pred CAR")
hist.gwr <-  histdens(results$pred, "Pred GWR")


```

Mapeando os valores observados e preditos dos modelos ajustados

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

library(colorspace) # 

setor.sf$brks <- cut(setor.sf$tx, include.lowest=TRUE,  right=TRUE,
                     breaks=c(-4, 0, 2, 4, 10, 57), 
                     labels=c("0", "0 - 2", "2 - 4", "4 - 10", "> 10"))

tx.bruta <- ggplot(setor.sf) + 
  geom_sf(aes(fill = brks), color = 'black') +
  ggtitle("Taxa Bruta") + 
  scale_fill_discrete_sequential(palette ='Heat2',  
                                 c1=80,c2 =30,l1=30,l2=90,p1=0.2,p2=1.5,
                                 na.value = "grey75", 
                                 drop=FALSE,
                                 name='Taxa') +
  theme_void()



setor.sf$brks.lm <- cut(dourados.lm$fitted.values, lowest=TRUE,  right=TRUE,
                        breaks=c(-4, 0, 2, 4, 10, 57), 
                        labels=c("0", "0 - 2", "2 - 4", "4 - 10", "> 10"))


pred.lm <- ggplot(setor.sf) + 
  geom_sf(aes(fill = brks.lm), color = 'black') +
  ggtitle("Taxa Predita - LM") + 
  scale_fill_discrete_sequential(palette ='Heat2',  
                                 c1=80,c2 =30,l1=30,l2=90,p1=0.2,p2=1.5,
                                 na.value = "grey75", 
                                 drop=FALSE,
                                 name='Taxa') +
  theme_void()

setor.sf$brks.car <- cut(dourados.car$fitted.values, lowest=TRUE,  right=TRUE,
                         breaks=c(-4, 0, 2, 4, 10, 57), 
                         labels=c("0", "0 - 2", "2 - 4", "4 - 10", "> 10"))


pred.car <- ggplot(setor.sf) + 
  geom_sf(aes(fill = brks.car), color = 'black') +
  ggtitle("Taxa Predita - CAR") + 
  scale_fill_discrete_sequential(palette ='Heat2',  
                                 c1=80,c2 =30,l1=30,l2=90,p1=0.2,p2=1.5,
                                 na.value = "grey75", 
                                 drop=FALSE,
                                 name='Taxa') +
  theme_void()

setor.sf$brks.gwr <- cut(results$pred, lowest=TRUE,  right=TRUE,
                         breaks=c(-4, 0, 2, 4, 10, 57), 
                         labels=c("0", "0 - 2", "2 - 4", "4 - 10", "> 10"))


pred.gwr <- ggplot(setor.sf) + 
  geom_sf(aes(fill = brks.car), color = 'black') +
  ggtitle("Taxa Predita - GWR") + 
  scale_fill_discrete_sequential(palette ='Heat2',  
                                 c1=80,c2 =30,l1=30,l2=90,p1=0.2,p2=1.5,
                                 na.value = "grey75", 
                                 drop=FALSE,
                                 name='Taxa') +
  theme_void()

library(gridExtra)
grid.arrange(tx.bruta, pred.lm, pred.car, pred.gwr, ncol=2)

```

Verificando a distribuição dos resíduoas .

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

library(vioplot)

vioplot(dourados.lm$residuals, dourados.car$residuals, results$residuos, names=c("LM", "CAR", "GWR"), col="orange")

title("Gráficos violinos da distribuição dos resíduos")

```

Mapeando os resíduos dos modelos ajustados

```{r echo=T, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="80%", comment=NA, results='markdown'}

library(colorspace) # 

setor.sf$brks.res.lm <- cut(dourados.lm$residuals, include.lowest=TRUE,  right=TRUE,
                            breaks=c( -14, -5, -1, 1, 5, 52), 
                            labels=c("< -5", "-5 a -1", "0", "1 a 5", "> 5"))

res.lm <- ggplot(setor.sf) + 
  geom_sf(aes(fill = brks.res.lm), color = 'black') +
  ggtitle("Resíduos - LM") + 
  scale_fill_discrete_sequential(palette ='Purple-Yellow',  
                                 c1=80,c2 =30,l1=30,l2=90,p1=0.2,p2=1.5,
                                 na.value = "grey75", 
                                 drop=FALSE,
                                 name='Taxa') +
  theme_void()

setor.sf$brks.res.car <- cut(dourados.car$residuals, include.lowest=TRUE,  right=TRUE,
                             breaks=c( -14, -5, -1, 1, 5, 52), 
                             labels=c("< -5", "-5 a -1", "0", "1 a 5", "> 5"))

res.car <- ggplot(setor.sf) + 
  geom_sf(aes(fill = brks.res.car), color = 'black') +
  ggtitle("Resíduos - CAR") + 
  scale_fill_discrete_sequential(palette ='Purple-Yellow',  
                                 c1=80,c2 =30,l1=30,l2=90,p1=0.2,p2=1.5,
                                 na.value = "grey75", 
                                 drop=FALSE,
                                 name='Taxa') +
  theme_void()


setor.sf$brks.res.gwr <- cut(results$residuos, include.lowest=TRUE,  right=TRUE,
                             breaks=c( -14, -5, -1, 1, 5, 52), 
                             labels=c("< -5", "-5 a -1", "0", "1 a 5", "> 5"))

res.gwr <- ggplot(setor.sf) + 
  geom_sf(aes(fill = brks.res.gwr), color = 'black') +
  ggtitle("Resíduos - GWR") + 
  scale_fill_discrete_sequential(palette ='Purple-Yellow',  
                                 c1=80,c2 =30,l1=30,l2=90,p1=0.2,p2=1.5,
                                 na.value = "grey75", 
                                 drop=FALSE,
                                 name='Taxa') +
  theme_void()


library(gridExtra)
grid.arrange(res.lm, res.car, res.gwr, ncol=2)

```



## Bibliografia sugerida

Interactive Spatial Data Analysis by Trevor C. Bailey , Anthony C. Gatrell Routledge, 1995 

Applied Spatial Statistics for Public Health Data;  Lance A. Waller, Carol A. Gotway  Wiley-Interscience 1St ed. 2004

Applied Spatial Data Analysis with R;  Roger S. Bivand, Edzer Pebesma , Virgilio Gomez-Rubio Springer; Edição: 2nd ed. 2013

* Online

- [Geocomputation with R](https://geocompr.robinlovelace.net/)